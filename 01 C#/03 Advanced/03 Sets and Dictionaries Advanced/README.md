# General
[Methods](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/01%20Methods.md#Dictionary)

[Commands](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/02%20Commands.md#Dictionary)

Dictionary-тата се наричат още асоциативни масиви и map-ове. Едно от предимствата им е, че могат да се използват за преброяване на данни различни от цели позитивни числа, за които може да ползваме и масиви.

При речниците, взимането / добавянето на елемент, проверката дали даден ключ съществува и махането на елемент, са много бързи. Примерно, търсенето на елемент в списък, отнема толкова операции, колкото са елементите в списъка. Също толкова бавно е и търсенето по стойност в речниците, поради което е желателно да търсим по ключ.

Всички типове данни, имат няколко метода, които са абсолютно еднакви, сред тях са:

`ToString();` - променя всеки тип данни в string.

`GetHashCode();` - връща hash кода на даденa стойност, независимо от какъв тип данни е.

Когато търсим дадена стойност в масив, ние проверяваме всеки един от елементите. Това търсене се нарича линейно. Сложността на алгоритъма линейно търсене в масива е n където n представлява броя на елементите.
## Hash table - Dictionary

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240415093357.png)

Hash таблицата е отново масив. Когато трябва да сложим дадена стойност, първо я прекарваме през hash функция, чиято единствена цел е за всяка входна стойност, независимо от типа данни, да върне цяло число. Hash функцията има константна сложност, която е най-бързата съществуваща `O(1)` - броя операции, не зависи от входните данни. Когато подаваме едни и същи входни данни на функцията, винаги получаваме един и същи резултат. За да се намери място в масива на стойността, която сме прекарали през hash функцията, полученото число се разделя с остатък на дължината на масива, където резултата ще бъде индекса на елемента в масива, където ще запишем стойността.
Това е много полезно, защото обръщането от дадена стойност в число през hash функцията е много бърза операция. Когато търсим определена стойност с метода `Contains.Key()` , Dictionary-то извиква `GetHashCode()` и от получения индекс, проверява дадения елемент в масива дали съдържа стойността. 

Понякога различни стойности, може да дадат еднакъв резултат след като разделим с остатък, това се нарича колизия. Има различни алгоритми за решаване на колизията, един от начините е стойността да се добави в съседния елемент в масива и когато търсим дадена стойност, да обхождаме и съседните няколко. Другия вариант е всеки елемент в масива, отново да е масив и там да съхраняваме стойностите, които са получили еднакъв индекс. Това отново ще бъде бърза операция, защото ще се налага да търсим с линейна сложност, но само в рамките на масива в дадения индекс.
Ако масива се препълни, тоест се налага много от стойностите да се слагат в едни и същи под масиви, то тогава главния масив удвоява размера си, и всички стойности се разпределят в новия масив. Отново се ползва тяхното непроменено hash число, но се разделя с остатък на новата дължина на масива.

За да работи цялата тази система правилно, то е много важно hash функцията да разпределя равномерно различните стойности, тоест да не връща едни и същи числа.
Трите важни неща за една hash функция е при едни и същи данни да дава еднакъв резултат, да бъде добре разпределена и да бъде бърза, защото ако не е бърза, де обезсмисля hash таблицата. Hash функциите, ползват по-битови операции и дори най-малката промяна тоест един бит да е по различен в дадена стойност или файл, това ще промени изцяло върнатото число от функцията. Най-ползваните такива функции са MD5 и SHA-2.
## Binary search - Sorted Dictionary

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240415093034.png)

Ползва се структура от данни, която се нарича Граф. Това са елементи, очертани обикновено с кръгчета и връзките между тях. Връзките имат различни свойства, може да са еднопосочни, двупосочни, могат да имат и тегла, тоест всяка връзка да има определено число или елемент към нея. Елементите се наричат още и връх и също могат да носят някаква информация. 
Има готови алгоритми за намиране на път, обхождане на граф, намиране на максимален поток, топологично сортиране, генериране на друга структура от данни и тн.
Сведем ли една задача до граф, ни се откриват стотици готови алгоритми, които може да приложим. Примерно приятелствата във фейсбук може да се представят чрез граф и може да намерим коя е най бързата връзка между нас и даден човек, тоест дали е приятел на приятел на приятел или е приятел на приятел. Или ако графа представлява градове, колко е пътя между два града. Или ако това са тръби, където връзките имат определен максимален поток, колко вода може да прекараме и тн.

Когато имаме граф, където нямаме възможност от един елемент, да се върнем назад или да зациклим между два елемента, то тази структура, се нарича дърво, защото изглежда на дърво, обърнато наобратно. Първия елемент се нарича корен, от него тръгват други елементи, които се разклоняват в още елементи и тн. Последните елементи в структурата, които нямат наследници, наричаме листа.
### Binary tree

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240415100638.png)

Това е дърво, където всеки един от елементите има най-много 2 наследника - двоично.
**Балансираното дърво** - е двоично дърво, което има минимална височина, всеки един връх има долу горе по два елемента. Ако дървото има само по един елемент и стане високо, се нарича изродено дърво.
**Дърво за търсене** - примерно ако имаме числа, то се спазва правилото за всяко разклонение от дясно да се слага по-голямо число, а от ляво по-малко. Всички числа от дясно на даден елемент, трябва да са по-големи от него и всички числа от ляво на елемента, трябва да са по-малки, това правило важи за всички.
Предимството данните да бъдат разпределени дървовидно а не в масив е, че ако търсим дадено число то ще бъде много по-бързо. В илюстрацията горе, ако търсим числото 31, започваме от корена 8 и знаейки че от ляво са по-малки числа от 8, то всички елементи от ляво ги пропускаме и продължаваме търсенето надясно. Проверяваме следващия елемент, който е 50 и всички елементи от дясно отново отпадат, следва 28 и след него намираме 31. Намирането е отнело 4 стъпки. Търсенето в такова дърво има сложност математически изразено с функцията `O(log2n)`. Обратно на дигането на степен е логаритмуването. Логаритмуването е функция, която взима едно число и връща друго число. Колкото повече растат входните данни, толкова е по-добре ползването на алгоритъм с не линейна сложност. За сравнение - ако имаме броя на елементите n = 1 милиард, линейната сложност ще бъде 1 милиард стъпки, а двоичното дърво ще търси с 30 стъпки. Защо 30, защото при 1 милиард елемента в дърво, то ще има 30 нива, 2 на 30 степен е милиард и нещо.
Първия елемент е root и всеки елемент се явява child node на предишния елемент и parent node на долните елементи. Когато се обхождат елементите, обхождането в двоичното дърво е наречено - LCR.  Първо се започва от най-ниския краен ляв елемент, после се продължава към неговия parent node, след това се тръгва към дясното разклонение на този parent node, като отново се започва от най-ниския му ляв краен child node. Като се обходи цялата група от елементи спазвайки същия принцип, обхождането се изкачва с едно ниво нагоре, в случая на илюстрацията 1, след него другото ниво е 2, като се обходи цялата група от дясно на 2 се стига до центъра 8 и след това се започва от дясната част, следвайки същите правила.
Използва се алгоритъм, който определя коя стойност ще бъде сложена за корен, но принципа най-общо е че се взима средната стойност и така от ляво и дясно имаме приблизително еднаква бройка елементи. От ляво на корена се слага средното число на останалите, както и отдясно се слага средното число на по-големите елементи и така се определя по веригата до края.. Ако дървото тръгне в дадена посока и стане много високо, то програмата го пренарежда използвайки алгоритми за балансиране.
Принципа при този вид дървета е, че всички леви child nodes на даден parent, трябва да са по-малка стойност, а всички десни nodes, трябва да са с по-голяма стойност. 
## HashSet & SortedSet
Това са речник и сортиран речник, без стойности, само с ключ.
Елементите на HashSet-а, се пазят в същата hash таблица, която ползва и Dictionary-то, от където идва и голямата бързина, а елементите на SortedSet-a, се пазят в двоично дърво, както при SortedDictionary.
Може да се погледне и като списък, но в който може много бързо да добавяме, търсим и махаме елементи. 
Паралел с математиката е множеството, което съдържа уникални елементи, повторенията не са позволени. 
Може да добавяме един и същи елемент без да даде грешка, но ще си остане само един.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240415194703.png)


# Misc
Начин да представим ключа и стойността ползвайки `tuple deconstruction`:
```
foreach ((double key, int value) in countByNumbers)
{
    Console.WriteLine($"{key} - {value}");
}
```

DevOps-a е човека, който се грижи за дадено приложение - да има автоматизирани build-ове, да се стартират тестове, да се събират логов-е и да се проверява дали всичко работи коректно. Нещо средно между системен администратор, network support и програмист.
# ChatGPT
## Data storage
If we write a random string on the console in C# without saving it in a variable, is this string temporarily stored in the ram memory?

ChatGPT
Yes, when you write a string directly to the console in C#, it is temporarily stored in the RAM memory. However, it's important to note that the string is stored in memory managed by the operating system and the .NET runtime, not directly accessible or controlled by your C# code.

When you write a string to the console, the .NET runtime manages the memory allocation and deallocation for the string as part of its memory management system. The string is typically stored in the process's memory space until it's no longer needed, at which point the runtime may reclaim the memory for other purposes.

So, while the string may be temporarily stored in RAM, the exact details of how and when the memory is allocated and deallocated are managed by the .NET runtime and the underlying operating system.
## Double - Decimal difference
```
List<decimal> test = new List<decimal>();
test.Add(decimal.Parse("2.0000"));
Console.WriteLine(test[0]);
```
I found out that the output will be the same as the input but if it is a double instead of a decimal, the output will be without the zeroes only two.

ChatGPT
Yes, you're correct. The behavior you observed is due to the differences in how `decimal` and `double` numbers are formatted in C#.

When you parse a string representation of a number into a `decimal`, it preserves all significant digits, including any trailing zeros after the decimal point. Therefore, if you parse the string `"2.0000"` into a `decimal`, it will be stored with all the zeros, and when you print it, all digits including the trailing zeros will be displayed.

However, when you parse the same string representation into a `double`, the trailing zeros after the decimal point are not preserved because `double` is a binary floating-point type, which doesn't always have exact representations for decimal fractions. Therefore, when you print a `double` number, the trailing zeros are typically omitted unless they are necessary to represent the actual value.

Here's a comparison:
```
// Parsing the string "2.0000" into a decimal
decimal d = decimal.Parse("2.0000");
Console.WriteLine(d); // Output: 2.0000

// Parsing the same string into a double
double x = double.Parse("2.0000");
Console.WriteLine(x); // Output: 2

```
As you can see, the `decimal` preserves all significant digits, while the `double` omits trailing zeros after the decimal point. This difference in behavior is important to consider when working with different numeric types in C#.
# Bookmarks 

Course completion: 16.04.2024
