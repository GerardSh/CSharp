# General
[Methods](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/01%20Methods.md#)

[Commands](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/02%20Commands.md#)

## Recursion
Това е метод, който извиква себе си, докато не изпълни дадено условие.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240518090023.png)

Семпла репрезентация на пост инкрементация чрез рекурсия.

```
  public class Program
    {
        static void Main()
        {
            MyMethod(0);
        }

        static void MyMethod(int n)
        {
            if (n == 11)
            {
                return;
            }

            Console.WriteLine("Before recursion " + n);

            MyMethod(n + 1);

            Console.WriteLine("After recursion " + n);
        }
    }
```
### Pre and Post Actions

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240518095500.png)

Преди да бъде изпълнено условието, се изпълняват pre-actions. Когато даденото условие се изпълни, може да видим че числата започват да се отпечатват в обратен ред. Това се получава, защото при последното влизане в метода, условието е било изпълнено и сега започва връщане във всички предишни инстанции на метода. За всяка една от тях се изпълнява последната част от кода (post-actions), която е останала неизпълнена под рекурсивното извикване. 

Всяка рекурсия има базов кейс / дъно, когато се прекратява рекурсията и започва изпълнението на post-actions.
### Direct and Indirect Recursion
Direct - a method directly calls itself
Indirect - method A calls B, method B calls A
## Time complexity of algorithms
1. Constant time – O (1) - възможно най-бързо, където броя на елементите няма значение, примерно достъпването на даден елемент по индекс.
2. Linear time – O (n) - сложността е на база колко елемента има в колекцията. 
3. Logarithmic time – O (log n) - много бързо.
4. Quadratic time – O (n^2) - трябва да се избягва, може да си го представим като nested for цикли. Това е сложността на bubble и selection sort алгоритмите.
5. Cubic time – O (n^3)

Когато говорим за сложност при алгоритмите, винаги гледаме worst case, примерно търсения елемент се намира в края на колекцията, когато търсим линейно.
## Brute-Force Algorithms
Бруталните или Brute-Force алгоритми са методи за решаване на проблеми, при които се изпробват всички възможни комбинации, докато се намери решение. Те се използват често при атаки за разбиване на пароли, но могат да се прилагат и за други видове задачи, като например решаване на пъзели или оптимизационни проблеми.

Пароли и Криптография: Най-честото приложение на brute-force атаките е разбиването на пароли. Въпреки че е неефективно за дълги и сложни пароли, този метод все още може да бъде успешен срещу къси и слаби пароли.
Комбинаторни Проблеми: Те могат да се използват за решаване на комбинаторни проблеми, където всички възможни комбинации трябва да бъдат изпробвани, за да се намери оптималното решение.

Brute-force алгоритмите са мощни инструменти, когато се изчерпват всички възможни комбинации, но тяхната ефективност намалява значително с увеличаването на сложността на задачата. Ето защо силни и дълги пароли, които използват различни типове символи, са по-трудни за разбиване чрез brute-force атаки.
## Greedy Algorithms
Целта на един такъв алгоритъм е винаги да вземе най-правилното локално решение, което да доведе до глобалното решение. 
Има опасност от грешен резултат. Примерно ако трябва да намерим с колко най-малко монети може да съберем 18 стотинки, greedy подхода ще предпочете да взема една стотинка от 10, една от 5 и три по 1,  но правилното е една стотинка от 10, и две по 4.
Тези алгоритми, биват ползвани за оптимизиране на проблеми, като например да намерят най-краткия път от даден град до друг град. 
Използват се и за намирането на maximum increasing subsequence.
## Simple Sorting Algorithms

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240519231328.png)

Сортиращите алгоритми често се квалифицират по сложност, дали са recursive / non-recursive, stable / unstable и comparison / non comparison based.

`Array.Sort()` е много бърз, защото използва правилните алгоритми според колекцията.

Един от най-бавните алгоритми е `Bogosort`.
### Stability of Sorting

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240518202824.png)
### Selection Sort
Unstable алгоритъм, където тръгва от първия елемент в колекцията и търси надясно най-малкия елемент и си разменят местата. След това започва от следващия елемент и пак търси надясно най-малкия елемент с който да се размени.
### Bubble sort
Stable алгоритъм, при всяка итерация на вътрешния цикъл, най-малкия елемент гарантирано отива на позицията на i, след което започва пак същия процес спрямо новата позиция на i.

```
       int[] numbers = { 1, 22, 3, 4, 5, -6, 7, -1, 0};

            for (int i = 0; i < numbers.Length; i++)
            {
                for (int j = i + 1; j < numbers.Length; j++)
                {
                    if (numbers[j] < numbers[i])
                    {
                        int temp = numbers[j];
                        numbers[j] = numbers[i];
                        numbers[i] = temp;
                    }
                }               
            }
```
### Merge Sort

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240519141824.png)

Един от най-ефикасните алгоритми, използва рекурсия и спада към divide and conquer алгоритмите. Разделя листа на 2, след това и тях ги разделя на 2 докато не останат само листи с по 1 елемент и след това се merge-ват наобратно в един лист. Идеята е че се използва свойството където два сортирани листа е много по-лесно да се merge-нат в нов сортиран лист.
### Quick Sort 
Aлгоритъм за сортиране, който използва метода "разделяй и владей". Основните стъпки на алгоритъма са:
1. Избиране на опорен елемент (pivot): Обикновено се избира последният елемент от масива.
2. Разделяне: Масивът се преглежда и се подрежда така, че всички елементи, които са по-малки или равни на опорния елемент, се поставят пред него, а всички елементи, които са по-големи, се поставят след него.
3. Рекурсия: Алгоритъмът се прилага рекурсивно върху двете части на масива (преди и след опорния елемент).

Quick Sort е предпочитан заради своята ефективност.
## Searching Algorithms
Алгоритми, които търсят даден елемент в колекция.
Един от вариантите е линейно търсене, където сложността зависи от броя на елементите.
### Binary search
Намира елемент в сортирана структура. Взима даден сортиран масив и го разделя на две части и проверява търсения елемент дали е по-голям или по-малък от средния елемент. Спрямо това се насочва от ляво или дясно. След това, отново разделя взетата част на две и проверява дали търсения елемент се намира от ляво или дясно. Този цикъл се повтаря, докато остане само търсения елемент.
# Misc

# ChatGPT

# Bookmarks 
[Most important type of Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/most-important-type-of-algorithms/) - Да се видят всичките структури - DSA -> Data Structures

[HackerRank - Online Coding Tests and Technical Interviews](https://www.hackerrank.com/) - Допълнителни задачи за подготовка

[Data Structures with C# - септември 2023 (на запис) - Софтуерен университет](https://softuni.bg/modules/118/data-structures-with-csharp-septemvri-2023-na-zapis) - Допълнителен курс, след завършване на Web

[Algorithms Fundamentals with C# - Софтуерен университет](https://softuni.bg/opencourses/algorithms-fundamentals-with-c-sharp) - Допълнителен курс, след завършване на Web

Course completion: 19.05.2024
