# General
[Methods](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/01%20Methods.md#)

[Commands](https://github.com/GerardSh/SoftwareUniversity/blob/main/01%20C%23/99%20Resources/02%20Commands.md#)

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240507091326.png)


# General
[Methods](01%20Methods.md#)
[Commands](02%20Commands.md#)

Силата на generics е когато правим структура от данни, клас и тн, да може да му разрешим да работи с типове данни, които потребителите на нашия код избират. С други думи, да може потребителите на нашия клас да избират типа данни с който класа да работи. Идеята е да се преизползва един и същи клас с единствената разлика типа данни, които приема, като се направи един само един темплейтен клас, който може да приема различни типове данни.
Както класа е шаблон за обекти, така и generics са шаблон за класове.

Параметъра в триъгълните скоби се нарича типов.

Когато ползваме generics, C# генерира скрито от нас нов тип данни, където Т е заместено с типа данни, който сме посочили.
## Type safety
Типовата безопасност означава, че когато определим някакъв тип данни с който да работим, примерно списък от strings, тогава C# става много стриктен и всеки път като работим с този списък, ще има грешка, ако подаваме друг тип данни освен string. Когато искаме да работим с данните от този списък, C# ще знае предварително какви операции, може да приложим върху тях. Също няма как в C# където имаме типова безопасност, да сложим число в списък от стрингове.
## Classes
Когато дефинираме generic class, типа данни, който посочим при инициализирането ще бъде заместен там където имаме `T` вътре в кода на класа:

```
class GenericClass<T>
{
    public T First { get; set; }

    public T Second { get; set; }
}

class Program
{
    static void Main()
    {
        GenericClass<int> intGeneric = new GenericClass<int>();

        GenericClass<string> stringGeneric = new GenericClass<string>();
    }
}
```

В първия случай, пропъртитата First и Second ще бъдат от тип int, при втория обект, ще бъдат тип string.

Може да имаме и няколко типа данни, които да заместваме вътре в класа:

```
class GenericClass<T, T2, T3>
{
    public T First { get; set; }

    public T2 Second { get; set; }

    public T3 Third { get; set; }
}

class Program
{
    static void Main()
    {
        GenericClass<int, double, string> intGeneric = new GenericClass<int, double, string>();
    }
}
```

За пример, речниците приемат два типа данни, един за ключа и един за стойностите.
## Methods
Методите също могат да работят с generics, тоест параметрите на метода да не са фиксирани предварително, но да приемат различен тип данни. 
При дефинирането на метода, трябва да сложим `<T>`  след името му. Прието е да се пише `T`, но може да напишем нещо друго на негово място.

```
Console.WriteLine(4 + ReturnValue<int>(5)); // 9
Console.WriteLine(4 + ReturnValue<string>("5")); // 45

static T ReturnValue<T>(T value)
{
    return value;
}
```
## Object data type
Преди generics е имало `System.Collections`, които имат колекции, приемащи object като тип данни.
`SyStem.Collections.Generic` сa добавени малко след създаването на C#, но преди това се е ползвал оbject, който е основата на всеки тип данни. Примерно може да създадем object променлива, на която да й присвояваме каквито си искаме стойности. Може да я инициализираме като стринг, а после да й сложим цяло число или друг тип данни. 
Има като ограничение, че може да ползваме само 4 метода, които са валидни за всеки тип данни. 
Предимството е че както при generics, така и тук, може да направим клас, който да приема object като тип данни и така да работи с най-различни типове. Така губим типовата безопасност, защото в един списък от objects може да са от най-различни типове данни. За да може да използваме други методи, трябва да конвертираме object към дадения тип, стига да знаем какъв е.


# Misc

# ChatGPT

# Bookmarks 

Course completion: 