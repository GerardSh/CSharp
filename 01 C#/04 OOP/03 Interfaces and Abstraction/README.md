# General
Концепцията за абстракция означава, да игнорираме детайлите и да се концентрираме върху важното за един клас, за което много помагат интерфейсите, описвайки списъка от методи / пропъртита, които да описват същината и най-важното за класа.

Абстракцията, също като при енкапсулацията се опитва да скрива разни неща от класа, но при нея се скрива функционалност, която не е необходима на външния свят, за да не го разсейват с излишни детайли. Енкапсулацията се занимава основно със скриване и валидация на данните, то абстракцията се занимава повече с публичните неща, които един клас предлага, повече с функционалността и публичните възможности. С други думи, абстракцията намалява сложността по разбирането какво прави нашия клас и дава възможност на външния свят да достъпят само онези неща, които са важни за тях и да се абстрахират и игнорират детайлите. Това се постига чрез интерфейси, абстрактни класове и виртуални / абстрактни методи.

Скриването, игнорирането, премахването на методи, пропъртита, функционалност която ще си я имаме в класа, но ако не е нужна на външния свят, принципа е да я скриваме. Примерно помощен метод вътре в класа, трябва да си остане вътре. Публичните методи, трябва да са само тези, които са важни за класа.

Абстракцията има две направления / гледни точки:
1 - Скриването на ненужните неща от външния свят. Примерно ако имам клас студент, с вътрешен метод който му осреднява оценката, това за външния свят не е важно. Това което е важно е да извика един метод, който да върне оценката на студента, а не точно как се изчислява.
2 - Имаме нещо от реалния свят, което пренасяме в клас. Трябва да се вземат само детайлите, които са релевантни и важни за нашия клас и да се игнорира останалото. Примерно при клас студент, ние не се интересуваме от това колко е висок, как изглежда и тн, но взимаме само важните неща за нас като име, възраст, пол, оценки и тн..

Трябва да правим публични само членовете на класа, които ще се ползва отвън. Основната цел е да намалим сложността на кода, защото един проект с хиляди класове, ако всичко им е публично ще е много трудно да ги използваме. Примерно ако в даден клас има 20 метода, но реално само 3 са важните, а другите са помощни, ние няма да знаем кой от всичките да ползваме. Трябва да ровим в документацията, кода на класа, все неща които отнемат много време и точно това е идеята на абстракцията, да си го спестим. Трябва така да е направен класа, че само с поглед на публичните методи да се ориентираме какво правят.
Абстракцията ни помага да се фокусираме върху това какво прави даден клас, а не как го прави.

Правилната терминология когато говорим за интерфейси и наследяване е че един клас наследява друг клас и имплементира интерфейс, а интерфейсите, наследяват други интерфейси.

Принципа на абстракцията е да използваме най-базовия тип данни, който има всичко което ни трябва.

Абстракцията се постига чрез два подхода: интерфейси и абстрактни класове.
## Interface
Създава се както се създава клас, но вместо `class` се пише `interface`. Името трябва да започва с `I`. Интерфейса е нещо като договор, списък от публичните членове, които трябва да има един клас, в над 90% това са методи, също така има и пропъртита, events(свързани с мобилни и desktop приложения) и indexers. Това е само списък, без нищо друго - няма имплементация, няма тяло, само метод signature-a. Всеки клас, който подписва този договор е задължен да има нещата описани в интерфейса, с единственото изключение - името на параметрите на методите, може да се ползват и други имена.

Всички членове в интерфейса са публични.

Интерфейсите ни позволяват да групираме няколко класа с една и съща функционалност под една обща шапка. Примерно `IEnumerable` се имплементира от много класове.
Те имат много различна функционалност, но всички отговарят на общото свойство, че имат метода `GetEnumerator` и по конкретно, че могат да бъдат foreach-вани. Това ни дава голямо предимство и гъвкавост, че може да променяме в последствие, конкретиката с която работим. Когато даден код работи с базов клас или интерфейс и когато даден метод иска от нас  като параметър `IEnumerable` ние може да му подадем всеки един от класовете, които са имплементирали тоя интерфейс. Докато ако искания параметър е само List<Т>, то тогава нямаме гъвкавост. С други думи, абстракцията е важна и от тази гледна точка, че когато искаме по базов параметър, тогава нашия код може да бъде използван с много повече опции.
Един клас може да наследи само един друг клас, но може да имплементира много интерфейси, защото интерфейса е само списък от методи и пропъртита, докато класа има и функционалност и нещата стават по-сериозни.

Методи които нямат тяло, се наричат абстрактни. Всеки такъв метод, може да бъде в интерфейс или абстрактен клас. Ако е интерфейс няма нужда да се пише `abstract` при дефинирането му.

Интерфейса, може да стане тип данни на променлива, но тя не може да е равна на самия интерфейс, защото самия интерфейс няма никаква имплементация на списъка от методи в него, задължително трябва да посочим даден клас, който е имплементирал интерфейса, защото при него е добавена логика и тяло на методите. Такава променлива се нарича абстрактна. С други думи не можем да създаваме инстанция на интерфейс директно, защото интерфейсът е абстрактен тип, който само дефинира методите, които класовете трябва да имплементират. Интерфейсите не могат да бъдат инстанцирани директно. Вместо това, можем да създадем инстанции на класове, които имплементират даден интерфейс:

```
public interface IMyInterface
{
    void MyMethod();
}

public class MyClass : IMyInterface
{
    public void MyMethod()
    {
        Console.WriteLine("MyMethod implemented in MyClass");
    }
}

public class MyClass2 : IMyInterface
{
    public void MyMethod()
    {
        Console.WriteLine("MyMethod implemented in MyClass2");
    }
}

public class Program
{
    static void Main()
    {
        // IMyInterface @interface = new IMyInterface(); // Това е грешка

        // Създаване на инстанция на клас, който имплементира интерфейса
        IMyInterface @interface = new MyClass();
        @interface.MyMethod(); // Извикване на метода, имплементиран в MyClass

        // Пренасочване на променливата към друга инстанция, имплементираща интерфейса
        @interface = new MyClass2();
        @interface.MyMethod(); // Извикване на метода, имплементиран в MyClass2
    }
}

```

Общото между всички класове, които са имплементирали даден интерфейс е че всички ще имат описаните методи и пропъртита в интерфейса. Всички те влизат в групата на интерфейса. 

Можем да създадем променлива от типа на интерфейса и посочим даден клас, който е имплементирал този интерфейс, то ние ще имаме достъп, само до имплементацията на методите и пропъртитата в дадения клас и до нищо друго, което се съдържа в класа. Така имаме предимство че можем да присвоим всеки един от тези класове на променливата, но и ограничението да не може да ползваме другите неща намиращи се в класа.
Друго предимство е, че може да направим списък от типа на интерфейса и в него може да добавяме различни обекти от типа на класовете имплементиращи интерфейса и така ще имаме достъп само до техните имплементации на методите описани в интерфейса.
Трето предимство е, че може да имаме метод, който да приема като параметър типа на интерфейса и така може да му подадем всеки клас, който имплементира този интерфейс, няма да сме ограничени само до един клас. Този метод става абстрактен и може да работи с много различни типове. 

Може да имаме default метод в интерфейса, който да прави нещо и този метод ще бъде наличен за всички променливи, които са от типа на интерфейса, независимо кой клас са инициализирали. Това е добавено в C# 8.0 и не се ползва много.

```
public interface IMyInterface
{
    void MyMethod();

    // Default method implementation in the interface
    void Print()
    {
        Console.WriteLine("test");
    }
}

public class MyClass : IMyInterface
{
    public void MyMethod()
    {
        throw new NotImplementedException();
    }
}

public class MyClass2 : IMyInterface
{
    public void MyMethod()
    {
        throw new NotImplementedException();
    }
}

public class Program
{
    static void Main()
    {
        IMyInterface myInterface = new MyClass();
        IMyInterface myInterface2 = new MyClass2();

        // Using the default implementation of Print method
        myInterface.Print();
        myInterface2.Print();
    }
}
```

Предимство на интерфейсите пред класовете и абстрактните класове е, че може да имплементираме повече от един интерфейси в даден клас. 

Когато имаме наследяване и имплементация на клас, винаги въпрос записваме класа от който наследяваме след `:` и след това изреждаме със запетайка интерфейсите.

Един интерфейс, може да наследи друг интерфейс, където добавя методите на този интерфейс и добавя свои методи.

Всеки клас също имплементира интерфейсите, на друг клас когото наследява.
## Abstract class
Създава се както като клас, с ключовата дума `abstract` преди класа. Това са специални класове, които се правят с цел да бъдат наследявани.

Също като интерфейсите, абстрактните класове, не могат да бъдат инстанцирани, тоест не може да направим променлива от тип дадения клас, защото съдържат празни абстрактни методи.

Абстрактен е като интерфейса, но в същото време е и клас - може да има имплементация на методи, но може да има и методи, без имплементация. По средата между клас и интерфейс, което ни дава по-голяма гъвкавост, но и някои ограничения.

Абстрактните методи са виртуални методи без тяло. Всеки клас който наследява абстрактен клас, трябва да задължително да override-не абстрактните методи

Всеки клас, който не е абстрактен и имплементира абстрактен клас, е длъжен да имплементира абстрактните методи, тоест да ги override-не.

Абстрактните методи в класа, за разлика от интерфейсите, не е задължително да са публични. 
Друга разлика с интерфейсите е, че може да имаме и конструктори.

Ако абстрактен клас имплементира интерфейс задължително трябва да сложи ключовата дума `abstract` при методите от интерфейса, които ще остави празни.


## Abstraction vs Encapsulation
### Encapsulation
При енкапсулацията, скриваме основно данните минавайки ги през методи и код, който да ги валидира, това е с цел да защитим информацията, от външния свят. Трябва да сме сигурни че имаме коректно подадени данни, за да работи класа ни правилно.
Постига се основно чрез access modifiers и пропъртита.
### Abstraction
При абстракцията ние скриваме имплементационни детайли. Това означава метод, който върши помощна работа и който не е нужен на външния свят. Основната цел е да не затормозяваме колегата, който използва класа с неща които не го интересуват и да му дадем списък, само с важните неща от нашия клас, които трябва да са публични, другите модификатори нямат значение.
Постига се чрез абстрактни класове и интерфейси.
## Public API
Само важните неща от класа трябва да са публични, всичко останало трябва да е private.
# Misc
Един от най-честите въпроси при интервютата за работа е каква е разликата между интерфейс и абстрактен клас.

Външните библиотеки се инсталират и управляват чрез NuGet. NuGet е пакетен мениджър за .NET, който улеснява добавянето на библиотеки и зависимости към проектите.
## .NET / CSharp
.Net е цялостната платформа, SDK, компилатора, всичките готови неща, които ползваме. 
C# е език, който ни позволява да пишем върху .NET, има много други езици, които може да пишат в .NET, C# е най-използвания.
## Public API - Application Programming Interface
Само важните неща от класа трябва да са публични, всичко останало трябва да е private. Една от основните отговорности на интерфейсите е - да опишат нещата които са публични за даден клас. Това са нещата които хората от вън, може да използват за да работят с нашето приложение / програма. Ако това е клас, това са публичните методи, ако е web service, това са адресите / функционалностите, които може да достъпят. API както и много други неща в IT сферата, като service, interface и тн, могат да значат различни работи в зависимост от контекста. 
## Class
По дефиниция, класа е описание върху даден език за програмиране на обект съществуващ в реалния свят. Класа проектира част от възможностите на този обект в езика за програмиране.
# ChatGPT

# Bookmarks 
