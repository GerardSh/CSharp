# General
## Seven Testing Principles
1 Тестването трябва да е зависимо от контекста - ако тестваме приложение, което е банков софтуер, трябва да наблегнем на неговата сигурност, с по-малка важност е формата за контакт, особено когато сме притиснати във времето.

2 Тестването на всички възможности, не е възможно - трябва да тестваме граничните случаи с приоритет. Ако нещо работи с 5, вероятно ще работи и с 6, но не е сигурно дали ще работи с 0, с голямо число, с отрицателно число и тн.
Списък който показва колко много гранични случаи може да имаме и то само при работата със стрингове:
[big-list-of-naughty-strings/blns.txt at master · minimaxir/big-list-of-naughty-strings](https://github.com/minimaxir/big-list-of-naughty-strings/blob/master/blns.txt)

3 Тестването трябва да започне максимално рано, защото колкото повече се отлага и колкото по-късно се хване даден проблем, то толкова по-скъпо излиза да се оправи.
Примерно Амазон имат бот който проверява цените по другите магазини и смъква, ако намери някъде по-евтино. Но другия магазин също е имал такъв бот и двата бота започват да си смъкват взаимно цената в продължение на няколко дена, докато в един момент продукта се продава на много по-ниска цена от неговата себестойност, което е довело до големи загуби. Проблема е бил че бота не е имал таван до колко най-ниско да смъква цената и ако този проблем беше хванат в началото, нямаше да се стигне до тези загуби.

4 Тестването да се раздели на модули и да се направи пропорционално спрямо важността на дадения модул. В този принцип се съдържа принципа 80/20 - 80% от проблемите обикновено се намират в 20% от функционалността на приложението.

5 Тестването са нещото което предпазва от наличието на бъг или предотвратяват неговата поява. С други думи, когато променяме даден код и не отразим промяната върху тестовете, може да се окаже че тестовете са неефективни, тоест кода е станал резистентен към тези тестове. 

6 Тестването показва наличието на проблем, но не показва липсата на проблеми. Трябва да сме наясно, че дори да минава нашия тест, това не означава че няма неоткрити бъгове.

7 Тестването и оправянето на проблеми, не може да валидира очакванията и изискванията на потребителите. Само клиента може да потвърди дали продукта отговаря на очакванията му.

Бонус принцип - ако едно място е създавало проблем, силно вероятно е да създаде отново, затова трябва да го подсигурим с тест.
## Manual Testing
Проверка дали всичко работи на ръка. Това е много бавна и повторяема операция, която трябва да се прави отново и отново при всяка промяна на кода. Примерно ако сме открили даден бъг и сме го оправили, трябва да започнем всички тестове отново. Този тестинг се прави само по изключение.
## Automated Testing
System tests - тестват генерално цялата система как работи в нейната цялост. Също как нашата система си комуникира с другите системи, примерно как нашето приложение си комуникира със системата за плащане. Това са тестове на много високо ниво.

Integration tests - тестове на по-ниско ниво, тестват в рамките на нашия код, дали два модула или два класа в комбинация един с други, работят коректно.

Unit tests - на най-ниско ниво. Обикновено тестват най-малката единица в нашия код, която са методите. Обикновено теста създава условията за един метод - създава инстанция за класа, извиква метода подавайки му някакви аргументи и като трета стъпка сравнява получения резултат с това което очакваме.

Regression test - термин за тест който пишем за да валидираме че открит бъг, няма да се случи втори път.

UI - това са тестове които ги правят QA - симулират потребителски действия и проверяват дали системата работи коректно.

Load - как работи наша програма под натоварване. Примерно дали става 10 секунди регистрацията, ако имаме 10000 човека в нашия сайт.

Performance - проверява за колко време се случва дадено нещо. Примерно ако регистрацията на потребител отнема повече от една секунда, теста трябва да даде грешка.

Stress - как се държи приложението в непозната за него среда. Примерно ако спрем изведнъж приложението и после го пуснем, дали ще е запомнило последните промени.

Security - дали дадени данни може да счупят или хакнат приложението.

Acceptance - валидират дали това което потребителя е поискал е изпълнено.

Black-box - тестване на система на която не знаем какъв й е кода.

A/B - тестване където примерно бутона купи се слага на различни места и след това гледат, кой бутон е реализирал най-много продажби и спрямо тази информация се решава постоянното му място.
## Unit Testing Frameworks
Във всеки език има такива frameworks, които правят тестването много удобно - дават възможност да се отделят тестовете в отделен проект и да покажат списъка с тестове в отделен прозорец, където срещу името на всеки тест, може да видим кой е минал успешно. Това е много по-удобно от това да пуснем програмата и да видим дали гръмне или не. Има и много други предимства и улеснения.

В .Net има три популярни frameworks, които си приличат много, това по което се различават е имената на атрибутите, имената на assert методите, останалото е почти същото.
### MSTest
Вграден в VS, идва си наготово от самия .Net
Липсват параметризирани тестове и някои други незадължителни функционалности.
## NUnit
Безплатен, с отворен код и работи перфектно.
## xUnit
Същото като NUnit.
## How to use
Създаваме нов проект и търсим примерно NUnit Test Project. Кръщаваме го с името на проекта, който искаме да тестваме и слагаме `.Tests` накрая. Това не е задължително условие, но така се прави за да се отрази че в този проект, се съдържат тестове. Създава се във версията на която е проекта, който тестваме. NUnit е библиотека, която се инсталира автоматично в проекта.

# Misc

# ChatGPT

# Bookmarks 
Списък който показва колко много гранични случаи може да имаме и то само при работата със стрингове:

[big-list-of-naughty-strings/blns.txt at master · minimaxir/big-list-of-naughty-strings](https://github.com/minimaxir/big-list-of-naughty-strings/blob/master/blns.txt)
