# General
Дизайн патърните са общо решение, на често срещан проблем в ООП. Повечето патърни се занимават с интерфейси, абстрактни класове, наследяване, група от класове и тн, като общата цел е да се постигне гъвкавост. Всеки патърн се стреми към спазване на SOLID принципите, добрите практики в ООП.
## Elements of a Design Pattern
### Name
Всеки pattern си има име. Когато искаме да обобщим конкретен подход, вместо да го обясняваме в детайли, може да го обясним с неговото название.
### Problem
Причината поради която имаме нужда от дизайн патърн. 
### Solution
Често към дизайн патърна, може да намерим и някакво негово решение - абстрактен код, показващ как са свързани нещата.
### Consequences
При използването на дизайн патърни, имаме последствия, като усложнена логика на кода, което е най-честия негатив. Примерно се решава някакъв проблем, но кода се разхвърля на повече места. В повечето случаи тези негативи са приемливи, при положение че кода става по-лесен за разширяване. По-лесното разширяване е с по-голям приоритет, пред това кода ни да е лесен за разбиране.
## Benefits and Drawbacks
### Benefits
Дизайн патърните са се наложили като названия и са като азбука на ООП. Всеки по-опитен програмист, би разбрал какво означава даден патърн и това улеснява комуникацията.
Поради дизайн патърните, няма нужда да измисляме решение за често срещани проблеми, което ускорява разработката.
### Drawbacks
Правят кода по-труден за разбиране и се изписва повече код за една функционалност.
Патърна не готов код, който може да преизползваме директно, трябва да се направят модификации.
Не са пригодени за juniors, защото изискват доста познания.
В някои случаи се получава "over design" - излишно усложнение на кода, защото патърните не са универсално решение за на всякъде. Примерно не трябва за нещо дребно, което може да се постигне в Main метода, да направим 30 класа.
За да се ползват, трябва да са много добре разбрани, както и много добро цялостно разбиране на ООП. 
## Types of Design Patterns
Има много патърни в IT света. Всяко нещо, което дава насока / решение на често срещан проблем, се нарича патърн.
Примерно искаме много устройства да си комуникират помежду си, през обща шина - service bus, това е архитектурен / cloud патърн.
Алгоритмите също може да ги наречем патърни, за решаване на различни проблеми, свързани със структурите данни.
Дизайн патърните са за проблеми в ООП и техните решения.

Има три основни типа патърни:
### Creational
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240804200500.png)

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240804223022.png)

Занимават се основно с конструирането или получаването на нов обект.
#### Singleton
Singleton е шаблон за дизайн, който гарантира, че от даден клас съществува само един екземпляр в рамките на приложението. Това е полезно в ситуации, където е необходимо централизирано управление на ресурс или глобална точка за достъп, като например управление на конфигурационни настройки или връзки с базата данни. Този шаблон осигурява глобална точка за достъп до единствения инстанциран обект и предотвратява създаването на повече от един обект от класа.
#### Factory Method
Factory Method е шаблон за дизайн, който предоставя интерфейс за създаване на обекти в суперкласа, но позволява на подкласовете да променят типа на създадените обекти. Това позволява на клиентския код да работи с обекти, без да знае техния точен тип и как се създават. Това е полезно, когато имаме нужда от повече гъвкавост при създаването на обекти и искаме да делегираме този процес на подкласове.
#### Abstract Factory
Abstract Factory е шаблон за дизайн, който осигурява интерфейс за създаване на свързани или зависими обекти, без да се специфицира техния конкретен клас. Този шаблон позволява създаването на цели "семейства" от свързани обекти, които трябва да се използват заедно, като например различни GUI елементи (бутони, текстови полета, чекбоксове) в различни стилове (Windows, macOS). Основното предимство е, че клиентският код остава независим от конкретните класове на създаваните обекти.
#### Builder
Builder е шаблон за дизайн, който се използва за създаване на сложни обекти с много части или стъпки. Този шаблон разделя процеса на създаване на обект от неговото представяне, което позволява да се конструират различни варианти на обекта с едни и същи процеси на създаване. Builder е особено полезен, когато обектите имат много опционални параметри или при създаването на различни конфигурации на един и същи тип обект.
#### Prototype
Prototype ни дава възможност да клонираме даден обект. Ако искаме да направим копие на референтен тип обект, не може да му кажем ref1 = ref2, защото това е копиране на референцията, която сочи към една и съща памет, тоест две променливи, сочат към една и съща памет.
Чрез prototype, се решава този проблем, защото в .Net не се подържа вградено. Prototype взима даден обект и прави копие на състоянието му както е точно в момента. 
В .Net имаме вграден интерфейс `ICloneable`, който дава метода clone. Разписвайки този метод, трябва да измислим начин, да копираме обекта, на ново място в паметта. Когато имаме стринг или примитивни типове данни, нещата са лесни, защото ги хващаме и ги пренасяме. Проблема е, ако имаме много клас членове, трябва да ги копираме един по един.
##### Shallow copy
Решението в .Net е вградения метод `MemberwiseClone()`, който ще направи нова памет и ще копира един по един всеки един от байтовете. Този вид копиране се нарича shallow copy, като минуса е, че ако в класа имаме друг референтен тип - примерно в класа `Car` имаме `Engine` то `MemberwiseClone()` ще направи нов обект на класа `Car`, но и двата обекта ще сочат към един и същи `Engine` обект. Затова се нарича повърхностно копиране, защото копира само първото ниво и само стойностните типове.
##### Deep copy
Истинско копиране може да се направи с reflection, който да мине рекурсивно и да копира всички референтни типове, както и техните референтни типове, независимо на кое ниво се намират. Това се нарича deep copy.
#### Fluent Interface
Fluent Interface не решава реален проблем, но решава това как да ни бъде по-удобно създаването на дадено нещо. Може чрез точки, да изреждаме неща, които искаме да се случат върху обекта, както работим в LINQ, където изреждаме различни методи един след друг, които искаме да изпълним върху дадена колекция.
Когато създаваме обекта, вместо да правим един голям `new` и вътре да изреждаме много неща със запетайки, изреждаме нещата с методи. Удобството на този патърн е, че може да изредим нещата във всякаква комбинация и ред. Другото удобство е, че като натиснем `.` във VS ще ни излезе пълния списък с неща, които може да направим. Всеки от тези методи, трябва да слага дадената стойност и да връща целия обект, за да може веднага след това да се извърши следващата промяна, без прекъсване.
Може да даваме различен достъп на потребителя, спрямо ситуацията, кой точно метод, му е наличен към момента. Примерно в LINQ, преди да ползваме `OrderBy()` нямаме възможност да извикаме `ThenBy()`, защото `OrderBy()` връща `IOrderedEnumerable<T>` колекция, която има и `ThenBy()`.
#### Object Pool
Object Pool е шаблон за дизайн (design pattern), който се използва за оптимизиране на управлението на ресурси чрез повторна употреба на обекти, вместо те да бъдат създавани и унищожавани многократно. Този шаблон е особено полезен в ситуации, където създаването на обекти е скъпо (като в смисъл на ресурси или време) и когато обектите могат да се използват многократно.

Когато се използва Object Pool, създаваме пул от обекти, от които можем да заемем обект, когато ни е необходим, и след като го използваме, го връщаме обратно в пула, вместо да го унищожим. Това позволява значителна оптимизация, особено при често използвани ресурси като бази данни, мрежови връзки или големи обекти в паметта.

Основното предимство на този подход е, че значително се намаляват разходите по създаване и унищожаване на обекти, като същевременно се подобрява производителността на системата. Пример за използване на Object Pool може да бъде в игри, където имаме голям брой врагове или куршуми, които се създават и унищожават често. Вместо всеки път да създаваме нов обект, ние ги заемаме от пула и ги връщаме след употреба.
#### Lazy Initialization
Lazy Initialization е шаблон за дизайн, който се използва за отлагане на създаването на обект, докато той не стане наистина необходим. Този шаблон е особено полезен за оптимизиране на производителността и използването на ресурси, като се избягва предварителната цена на създаване на обект.
- Отложено създаване: Обектът се създава само когато бъде достъпен за първи път, спестявайки ресурси, ако обектът никога не бъде използван.
- Оптимизация на производителността: Полезен е за обекти, които са скъпи за инициализиране, като сложни данни или ресурси, които изискват значителна настройка.
- Сигурност при многопоточност: В многопоточни приложения е необходима правилна синхронизация, за да се гарантира, че обектът се инициализира само веднъж, предотвратявайки създаването на множество инстанции от различни нишки.
- Пример за използване: Клас, който извършва тежки изчисления или зарежда големи файлове с данни, инициализира тези ресурси само когато функционалността на обекта бъде наистина извикана.

В .Net класът `Lazy<T>` предоставя лесен и безопасен начин за имплементиране на лениво инициализиране. Той осигурява отложено създаване на обект, като се грижи за всички аспекти на синхронизацията и проверките, които са необходими в многопоточни среди.

Lazy Initialization оптимизира използването на ресурси и производителността чрез отлагане на създаването на обект до момента, в който той е наистина необходим, което помага за управление на скъпи операции и намаляване на ненужната overhead. Нужни са правилни мерки за синхронизация при многопоточни сценарии. 
С други думи, оставяме даден обект празен в Lazy класа и ако някъде в кода обекта бива поискан, Lazy ще прецени дали обекта го има създаден или трябва да го създаде и да го върне.

Семпла Lazy репрезентация:

```
using System;

public class SimpleLazy<T>
{
    private readonly Func<T> _valueFactory;
    private T _value;
    private bool _isValueCreated;

    // Constructor that takes a lambda expression (Func<T>) to initialize the object
    public SimpleLazy(Func<T> valueFactory)
    {
        _valueFactory = valueFactory ?? throw new ArgumentNullException(nameof(valueFactory));
    }

    // Property to access the value
    public T Value
    {
        get
        {
            // Check if the value has already been created
            if (!_isValueCreated)
            {
                // Create the value using the provided lambda expression
                _value = _valueFactory();
                _isValueCreated = true;
            }
            return _value;
        }
    }
}

// Example usage
public class ExpensiveResource
{
    public ExpensiveResource()
    {
        // Simulate an expensive initialization
        Console.WriteLine("ExpensiveResource is being initialized.");
    }

    public void DoWork()
    {
        Console.WriteLine("ExpensiveResource is working.");
    }
}

public class Program
{
    public static void Main()
    {
        // Create an instance of SimpleLazy with a lambda expression to initialize ExpensiveResource
        var lazyResource = new SimpleLazy<ExpensiveResource>(() => new ExpensiveResource());

        // Accessing Value triggers the initialization of ExpensiveResource
        lazyResource.Value.DoWork(); // Output: ExpensiveResource is being initialized. \n ExpensiveResource is working.

        // Subsequent access will use the already created ExpensiveResource
        lazyResource.Value.DoWork(); // Output: ExpensiveResource is working.
    }
}
```
### Structural
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240817173115.png)

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240817173050.png)
Взаимовръзката между класовете, на ниво структура и комбинация между различни класове. Също и как може да ги комбинираме за да получим нещо ново.
Двете основни връзки между класовете са наследяване и композиция - когато даден клас използва като поле, пропърти или параметър на метод друг клас. Използва се най-вече композиция - комбинация между класове. Идеята е да може да приложим Open - Closed принципа. Целта е да си улесним / подобрим дизайна на класовете, прилагайки този тип патърни. 
#### Facade
Facade ни дава възможност да групираме йерархия или група от класове и да ги скрием зад някакъв клас, който да ни дава тяхната пълна функционалност, скривайки детайлите по тяхното използване. Когато изкараме методи на преден план, които са удобни за ползване върху структура от класове. 
#### Composite
Composite прави възможно интерпретацията на едно нещо, по същия начин, по който може да интерпретираме група от неща. Създава дървовидна структура, в която обектите и техните комбинации могат да се използват взаимозаменяемо. Всяко нещо, което може да бъде представено като дърво, се базира на composite.
#### Flyweight
Flyweight се грижи за това направени вече обекти, да ги имаме само веднъж. Примерно в един word документ, имаме много букви. Точното визуализиране на всяка една от тези букви е записана някъде и всяка буква преизползва тази информация - самата сложност по изрисуването на буквата. Може да има различия в размер, шрифт и тн, но сложността е на едно място. С други думи се използва за минимизиране на използването на паметта чрез споделяне на обекти, които имат общо състояние. Той разделя състоянието на обектите на външно и вътрешно, като споделя вътрешното състояние между многобройни обекти, за да се намали консумацията на паметта.
#### Proxy
Proxy скрива даден клас зад себе си и играе ролята на посредник, при работата с този клас.
Proxy предоставя заместител или представител на друг обект, който контролира достъпа до него. Proxy класовете могат да добавят допълнителна логика за достъп, като кеширане, защита или отложена инициализация.
#### Decorator
Decorator позволява добавяне на нови функционалности към обект по време на изпълнение, без да се променя самият обект. Той динамично разширява поведението на обектите чрез "обвиване" на обекта в нов клас, който добавя допълнителна функционалност.
#### Adapter
Adapter решава следния проблем - имаме външна библиотека, която има определени класове и искаме да приобщим техните неща, към нашия код, чрез интерфейс. Когато нещо не отговаря на нашите интерфейси, правим адаптер, който отговаря на тях и адаптира идващото от външния клас и което ни трябва на нас.
#### Bridge
Bridge е вдигане на абстракцията - връзва интерфейс към интерфейс, вместо конкретно към конкретно. Това е полезно, когато има множество варианти на абстракции и реализации, които трябва да бъдат комбинирани по различни начини.
### Behavioral
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240817190557.png)

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240817190634.png)

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240817190702.png)

Занимават се функционалността, с методите, с кода, с това което реално класовете правят и къде трябва да отиде дадено парче код. 
Разпределят кода по отделните класове. Повечето патърни са от този тип. Както и при structural patterns, получаваме гъвкавост, по-добре структуриран код и стремеж към спазване на SOLID.
#### Chain of Responsibility
Chain of responsibility, позволява на обектите да предават заявки по верига от обработващи обекти. Всеки обект във веригата решава дали да обработи заявката или да я предаде на следващия обект. С други думи - нареждаме обекти като свързан списък и почваме от първия, който първи си хареса това, което трябва да обработи, го обработва.
#### Iterator
Iterator ни дава възможност да обхождаме колекции, дори когато обхождането им, не е тривиално, както при масив. Това е клас, който съдържа логиката, как са обхожда дадена структура от данни. В C#, Iterator патърна има вградения интерфейс `IEnumerator` и е залегнал и във синтаксиса чрез foreach цикъла. С други думи - изнасяме обхождането в отделен клас, който наричаме Iterator.
#### Command
Command групира функционалности, като им дава обща структура. Превръща заявките за извършване на действия в обекти. Това позволява отлагане на изпълнението, подреждане на командите в опашка, запис на действия за повторно изпълнение и осъществяване на отмяна на операции.
#### Template Method
Template method е свързан с това да направи обща функционалност за няколко класа, но някъде по средата на тази функционалност, остава дупка / hook, която наследниците на този клас трябва да запълнят. Идеята е да дефинира скелета на алгоритъм в метод, оставяйки някои стъпки да бъдат дефинирани от подкласовете. Този патърн позволява на подкласовете да променят определени части от алгоритъма, без да променят неговата структура. С други думи - abstract класа оставя недовършена функционалност в темплейт метода и оставя наследника да го довърши.
#### Strategy
Strategy се използва доста често, когато искаме да използваме Dependency Inversion принципа или когато искаме дадена функционалност да му дадем възможност да има много имплементации. Определяме метода, правим го в интерфейс, описваме метода и вече използваме интерфейса, вместо конкретния клас.
#### Observer
Observer се използва за създаване на зависимост от тип едно към много между обекти. Когато състоянието на един обект (субект) се променя, всички зависими обекти (наблюдатели) се уведомяват и автоматично се актуализират.

Основни концепции:

- Субект: Обектът, който поддържа списък на наблюдатели и ги уведомява за всяка промяна в състоянието си.
- Наблюдател: Обекти, които са регистрирани да получават актуализации от субекта.
- Уведомление: Когато състоянието на субекта се променя, се задейства уведомление към всички регистрирани наблюдатели, обикновено чрез извикване на техните методи за актуализация.

Използване в C#:

- Events: В C# Observer Pattern често се имплементира чрез събития. Събитието е специален вид делегат, който представлява списък от методи, на които може да се абонира и да бъдат извикани, когато събитието бъде повдигнато.

```
public class Subject
{
    // Declare an event of type delegate
    public event Action<int> OnChange;

    private int _state;

    public int State
    {
        get => _state;
        set
        {
            _state = value;
            // Raise the event to notify observers
            OnChange?.Invoke(_state);
        }
    }
}

public class Observer
{
    public void Subscribe(Subject subject)
    {
        subject.OnChange += Update;
    }

    private void Update(int newState)
    {
        Console.WriteLine($"State changed to {newState}");
    }
}

```

Summary:
- Observer Pattern: Определя едно към много отношение между обекти за автоматични актуализации.
- Events: В C# събитията се използват за имплементиране на Observer Pattern и държат списък от методи, които да бъдат извикани, когато събитието бъде задействано. Този патърн улеснява декуплирането, като субектът и наблюдателите взаимодействат чрез събития, което насърчава по-добра модуларност и гъвкавост в кода.
#### Mediator
Mediator централизира комуникацията между компонентите чрез медиационен обект. Вместо компонентите да взаимодействат директно помежду си, те комуникират чрез медиатора, който управлява логиката на комуникацията и координира взаимодействията. Този патърн помага за намаляване на директните зависимости между компонентите, правейки системата по-гъвкава и по-лесна за поддръжка.

Централизирайки комуникацията, Mediator Pattern насърчава слабото свързване, позволявайки на компонентите да функционират независимо един от друг. Това централизирано управление опростява управлението на взаимодействията и прави поддръжката по-лесна, тъй като промените са ограничени до медиатора, а не до всички компоненти директно.

Например, в приложение за чат, медиаторът `ChatRoom` ще управлява обмена на съобщения между компоненти `User`, като осигурява, че потребителите комуникират чрез чата, а не директно. Този подход помага за управление на сложни взаимодействия ефективно и поддържане на ясно разграничаване между различните части на системата.
#### Memento
Memento се използва за запазване и възстановяване на състоянието на обект, без да се разкрива вътрешната му структура. Този патърн позволява състоянието на обекта да бъде запазено и по-късно възстановено, улеснявайки операцията на отмяна или управление на състояния, без да се нарушава енкапсулацията.

Memento Pattern включва три ключови компонента: Originator, Memento и Caretaker. Originator е обектът, чийто статус трябва да бъде запазен. Memento държи състоянието на Originator и се използва за възстановяването му по-късно. Caretaker е отговорен за управлението на Memento, включително съхраняването и извличането му, когато е необходимо.

Този патърн помага за поддържане на енкапсулацията, като гарантира, че вътрешното състояние на Originator не се разкрива навън. Той опростява процеса на запазване и възстановяване на състояния, което улеснява имплементирането на функции като отмяна или управление на сложни състояния.

Например, в приложение за текстов редактор, Memento Pattern може да се използва за запазване на състоянието на документ. `Document` (Originator) може да запази текущото си състояние в `DocumentMemento` (Memento), и по-късно състоянието може да бъде възстановено, ако е необходимо. `VersionControl` (Caretaker) управлява тези ментори, позволявайки на потребителите да се върнат към предишни версии на документа, без да се разкриват вътрешните детайли на състоянието на документа.
#### State
State позволява на обект да промени поведението си, когато вътрешното му състояние се промени. Вместо да има множество условни оператори, които проверяват текущото състояние на обекта, този патърн организира различните състояния в отделни класове и прехвърля отговорността за поведението на тези класове.

State Pattern включва три ключови компонента: контекст, състояние и конкретни състояния. Контекстът е обектът, който поддържа препратка към текущото си състояние и делегира поведението си на този обект. Състоянието е интерфейс или абстрактен клас, който дефинира общите операции, които всички конкретни състояния трябва да реализират. Конкретните състояния са отделни класове, които реализират различните поведения на обекта в зависимост от състоянието му.

Този патърн улеснява добавянето на нови състояния, като същевременно поддържа кода чист и лесен за разбиране. Преходите между състоянията са ясни и не изискват сложни условни конструкции.

Например, в игра може да има герой, който има различни състояния като "бягане", "скачане" и "почивка". Всеки от тези състояния ще бъде реализиран в отделен клас, а героят (контекстът) ще променя своето поведение в зависимост от текущото си състояние. Ако героят получи команда за "скок", докато е в състояние на "бягане", той ще промени състоянието си на "скачане" и ще изпълни съответното поведение.

State Pattern помага да се избегне усложняване на кода, като същевременно прави системата по-гъвкава и лесна за разширяване с нови състояния и поведения.
#### Interpreter
Interpreter се използва за дефиниране на граматика за език и за интерпретация на изрази, написани на този език. Този патърн е полезен, когато имаме език, който искаме да парсираме и изпълняваме, например математически изрази, команди или скриптове.

Патърнът Interpreter включва следните ключови компоненти: контекст, абстрактен израз и конкретни изрази. Контекстът съдържа информацията, която е необходима за интерпретацията на изразите. Абстрактният израз дефинира интерфейса или абстрактния клас за всички изрази. Конкретните изрази реализират този интерфейс, като дефинират специфични интерпретации за различни части от езика.

Този патърн улеснява добавянето на нови правила и разширения към езика, като същевременно запазва основната логика на интерпретацията отделена и организирана.

Например, ако искаме да интерпретираме аритметични изрази като "5 + 3 - 2", можем да създадем класове за всеки оператор (като събиране и изваждане) и числа. Всеки конкретен израз ще знае как да интерпретира себе си и ще извършва съответната операция върху числата.

Interpreter патърн е полезен в системи, където трябва да се работи с често променящи се или разширяващи се езици, като прави управлението на граматиката и синтаксиса по-гъвкаво.
#### Specification
Specification се използва за дефиниране на бизнес правила и логики в отделни, спецификации, които може да се преизползват и комбинират. Този патърн позволява да се отделят бизнес правилата от логиката на приложението, като предоставя по-гъвкав и лесен за управление начин за проверка на условия и критерии.

Основните компоненти на Specification патърна включват:

1. Спецификация (Specification): Това е интерфейс или абстрактен клас, който дефинира метод за проверка на условие (обикновено наречен `IsSatisfiedBy`). Този метод приема обект и връща булева стойност, показваща дали обектът отговаря на дадената спецификация.
2. Конкретни спецификации (Concrete Specifications): Това са класове, които реализират интерфейса на спецификацията и съдържат специфични логики за проверка на условия.
3. Комбинирани спецификации (Composite Specifications): Спецификациите могат да се комбинират чрез логически операции като AND, OR и NOT, за да се създават по-сложни правила.

Specification е полезен, когато има нужда от проверка на обекти спрямо множество условия или когато бизнес логиката трябва да бъде лесно променяна и разширяема. Например, в една система за управление на поръчки, можете да имате спецификации за валидиране на това дали дадена поръчка е активна, дали е в определен статус, дали отговаря на определени ценови критерии и т.н. Тези спецификации могат да се комбинират, за да се извършват сложни проверки на поръчките.

Този патърн улеснява промяната и разширяването на бизнес логиката, като предоставя централизирано място, което може да се преизползва и служи за управление на правилата и условията.
#### Visitor
Visitor позволява добавяне на нови операции върху обекти от съществуващи класове, без да се променя техният код. Този патърн разделя алгоритмите от обектите, върху които се изпълняват, като предоставя възможност за лесно добавяне на нови операции чрез "посетители" (visitors).

Основни компоненти на Visitor патърна:

1. Посетител (Visitor): Това е интерфейс или абстрактен клас, който декларира методи за посещение на всеки тип обект от структурата. Всеки метод приема като параметър конкретен тип обект, върху който ще се извърши операцията.
2. Конкретни посетители (Concrete Visitors): Тези класове реализират интерфейса на посетителя и съдържат конкретни операции, които трябва да се извършат върху обектите. Всеки метод за посещение изпълнява специфична логика за работа с определен тип обект.
3. Елемент (Element): Това е интерфейс или абстрактен клас за обектите, които могат да бъдат посетени. Той съдържа метод за приемане на посетител, който обикновено се нарича `Accept`. Този метод приема като параметър обект от типа Visitor.
4. Конкретни елементи (Concrete Elements): Класовете, които реализират интерфейса на елементите, и са обектите, върху които ще се изпълняват операциите. В метода `Accept` те предават себе си като аргумент на съответния метод на посетителя.

Visitor патърнът е полезен, когато имате сложна структура от обекти и искате да добавяте нови функционалности, без да нарушавате съществуващия код на тези обекти. Например, в една система за обработка на документи, можете да използвате Visitor патърн за реализиране на различни операции като печат, експортиране, или изчисление на статистики, без да променяте самите класове на документите.

Този патърн улеснява добавянето на нови операции, като същевременно поддържа принципите на отвореност за разширение и затвореност за модификации (Open/Closed Principle).
# Misc

# ChatGPT

# Bookmarks 

[Gang of Four Design Patterns - Spring Framework Guru](https://springframework.guru/gang-of-four-design-patterns/) - препоръчана от Николай Костов, с уточнението че не е най-добре написаната.

Course completion: 18.08.2024
