# General
SOLID принципите са добри практики, към които се стремим, но не на всяка цена. Те са ориентир / рамка, кога един код е добре написан, а не закон, който на 100% трябва да се спазва. Не винаги са постижими, трябва да ги следваме до колкото можем, но без да плащаме високата цена, която е усложняване на кода.
## 1 Single Responsibility
Стремежа ни към това, един клас да върши една конкретна работа. 
Ако искаме да направим промяна в кода, тази промяна трябва да е на едно място.

Всеки клас трябва да е отговорен само за една част от целия софтуер, който пишем. Един клас не трябва да прави две несвързани помежду си неща. Когато много неща се случват в рамките на един клас е добре да бъде рефакториран - да изнесем класа в два отделни класа.

Начин за спазване на първия принцип е ако се замислим за всеки един метод, как той се отнася към името на класа - отговаря ли всеки метод на името на класа? Ако не или метода не е за този клас или името на класа не е правилно. Ако метода не е на място го местим в друг клас, ако проблема е в името на класа, се замисляме какво образуват групата от методи. Ако класа се казва Person а вътре говорим за оценки, университети и тн има два варианта: правим и Person и Student и правим връзка между тях или нямаме нужда от Person и преименуваме класа на Student, защото повече отговаря на списъка му от методи. Друг пример а ако имаме клас, който прави дадено изчисление, то визуализирането не трябва да е в същия клас. Може някъде в Main метода или отделен клас да ги свържем, но в рамките на класа, не би следвало да са заедно. Името на такъв клас би било `CalculateAndVisualize` не трябва да имаме `and` в името на класа.
Ако имаме университет където искаме да сложим и функционалност, трябва да го изнесем като отделен клас, но ако ни трябва само името на университета, може да го добавим като пропърти към класа Student.

Пример за лош код е примерно ако имаме правоъгълник и между нужните му пропъртита и формула за площ, има и метод Draw. Ако целта на цялата програма е рисуването на правоъгълници, това няма да е проблем. Ако обаче имаме по-голям софтуер, където имаме правоъгълник и искаме да го използваме в друг контекст, примерно да бъде част от фигура или да се използва за игра - да има повече от едно предназначение. Това, което трябва да се запитаме е дали за всички употреби на правоъгълника, метод Draw е ценен. Ако използваме правоъгълника само като геометрична фигура на която и смятаме лицето, тогава Draw е излишен и трябва да се измести в друг клас. 
Трябва да се запитаме - по повече от един начин ли използваме класа, ако отговора е да втория въпрос е дали при всички начини при които го ползваме има нужда от метода Draw. Ако отговора е да, метода остава в класа, ако е не, се изнася.

Друг пример: имаме книга, книгата си има Author, Location, Title и метод `TurnPage`. Трябва да се запитаме, кое от изброените неща е важно за книгата? В случая Location не е важен не променя книгата, защото дори да я преместим на друг рафт, си е пак същата книга. Поради това може да изместим Location в отделен клас, примерно Library, който се занимава да подрежда книгите и да ги съхранява. С други думи, изнасяме навън, нещото което не е свойствено за книгата, а именно нейната позиция на рафта. Така книгата може да се използва в програмата, без да е зависима от нейната позиция. Без тази промяна, този който ползва книгата, трябва да се чуди какъв Location да сложи - щеше да слага default стойности, което е почти сигурен знак, че нещото трябва да се изнесе.
### Loose Coupling
Един клас да не е свързан с прекалено много други класове - да няма много приятели. Да е обвързан с минимално класове, освен ако не са интерфейси или абстрактни. 
С други думи, до колко дадени единици класове са свързани помежду си. Добре е да нямаме твърде много връзки на един клас с други класове, защото се получава "спагети код" / tight coupling - когато направим код в който класовете са така обвързани с другите класове, че няма разплитане. Алтернативата е "ravioli code" / loose coupling - кода ни да е отделни парченца, които да не са свързани и лесно да може да ги извадим. Loose coupling се постига чрез абстракция - интерфейси, чрез това един клас да знае не за други класове, а за интерфейс, който да използва. 
Когато имаме интерфейси, получаваме малка групичка, а другата част е отделно нещо, без директна връзка. Имаме свързващо звено, което е интерфейса, а другата група от класове е независима. Единствения ни мост е интерфейса.
### Strong Cohesion
Свързан с това в един клас да имаме нещата, които са важни за класа, да не са пръснати на много места. В един клас, методите и пропъртитата трябва да са функционално силно свързани.
## 2 Open / Closed
Една система от класове / код, трябва да е отворена за разширение, но вече написан код, да е затворен за промяна / модификация. Разширението се постига, чрез абстракция и интерфейси. 
Този принцип носи едни от най-големите ползи - да може лесно да го разширяваме, без да се налага да поддържаме старата част на кода.
Трябва да се стремим, когато искаме да вкараме нова функционалност, да може да го правим, без да влизаме вътре в кода. Това много силно важи, ако нашето приложение използва библиотека отвън, примерно NuGet - централизирано хранилище в .Net, което ни позволява да качваме пакети и да ги преизползваме. Ако ни трябва работа с excel files, може да си инсталираме пакет с име примерно `ExcelFiles` което е външна библиотека, която я сваляме готова за използване, нямаме достъп до нейния код. Не може да влезнем вътре и да си добавим метод, трябва да следваме следния подход - така да се направи класа чрез абстракция, че да няма нужда да се добавят нови методи. Примерно ако имаме клас `PdfCreator` и вътре ни трябват методи които да изписват резултата от pdf-a, на конзолата или на файл или да го пратят по мейл, може да направим само един метод Write, който да приема като аргумент `IWriter` с необходимите методи за изписването на pdf-a, както и с готови класове `FileWriter` и `WebWriter`. Ако след време се наложи да добавим допълнителна функционалност, примерно да пратим резултата по мейл, може да си направим клас `EmailWriter`, имплементиращ `IWriter` и да го добавим като аргумент към Write метода. Така добавяме изцяло нова функционалност, без да променяме нищо в `IWriter` и `PdfCreator`:

![](Pasted%20image%2020240701195554.png)

![](Pasted%20image%2020240702120931.png)

Прилагаме този принцип, когато сме сигурни, че ще има нужда от промени и от вън ще искат да добавят ново поведение. Ако няма нужда, няма смисъл да се прилага, защото се плаща цена, когато се правят нещата чрез интерфейси, защото така кода става сложен за разбиране и поддръжка. 
Когато искаме да променим нещо веднъж, го променяме, но ако искаме втори и повече пъти да правим промяна, тогава трябва да спазваме принципа.
Трябва да приложим принципа също когато при промяна на нещо в кода, се налага да проверим дали всичко останало работи - вкарваме нещо ново в кода, което изисква да проверим дали всичко останало е наред. С този принцип, когато разширяваме нещо, ние си гарантираме че то работи, защото не сме го пипали. Трябва само да се тества новата функционалност и как си взаимодейства със старата.
## 3 Liskov Substitution
Кръстен е на жена програмист, която го е определила като добра практика. Наследниците трябва да са напълно заменяеми на местата където сме използваме базовия клас. Стремим се да използваме онзи тип данни, който е най-високо в йерархията, но ни върши работа. 
Дори да foreach-ваме нещо, ще подадем на метода IEnumerable а не примерно List, защото метода ще може да работи с много други класове.

![](Pasted%20image%2020240702172535.png)

Много важен въпрос при спазването на този принцип е примерно, ако имаме клас Person и клас Student наследяващ Person, дали ако подадем Student на метода, който очаква Person всичко ще работи без проблемно, без да се счупи нещо. Всеки един наследник, трябва да може да бъде подаван на местата, където се очаква базовия клас. 

Базовия клас никога не трябва да знае за наследниците си, трябва да е независим от тях.

Tell Don't Ask - когато искаме да извършим дадено действие, просто го вършим, без да питаме какъв е класа. Примерно ако имаме животни с метод издай звук, ние му казваме директно да издаде звук, без да го питаме какво животно е точно.

Ако имаме `is` почти сигурно принципа е счупен.

Друг принцип свързан и с наследяването - когато два класа имат обща функционалност, я изнасяме в базов клас и го наследяват. Това е популярен refactoring.

Не трябва да се ползват абстрактни и виртуални методи в конструктора.

Не винаги, когато казваме че едно нещо е друго нещо, наследяването е подходящо. Примерно това че всеки квадрат е правоъгълник, не значи че класа квадрат, може да наследи правоъгълник. Правоъгълника има две различни страни, квадрата има само една. Правилният вариант е да се направи общ клас Shape и да се наследява от квадрата и правоъгълника. Когато наследяваме даден клас, трябва да сме сигурни че всичките членове на базовия клас, ще бъдат приложими. 

Може да се обобщи с това да внимаваме в наследяването като си задаваме два въпроса - даден клас, дали е базовия клас и може винаги да го замества.
## 4 Interface Segregation
Нашите интерфейси не трябва да са огромни, да включват само взаимосвързани неща. Не трябва да слагаме твърде много методи в един интерфейс и да го препълваме, ако за един клас ще трябват само част от методите, за друг клас друга част. По-добре да ги разделим на отделни интерфейси, за да се наложи класовете да не имплементират методи, които няма да им трябват.
Ако някъде видим че имплементираме интерфейс, където дори само един метод не ни върши работа, то тогава ще е добре да разделим интерфейса на две.
Интерфейсите трябва да са кратки, името да отговаря на това което има вътре в него и нещата вътре да са свързани.

## 5 Dependency Inversion
Всички зависимости на нашия клас, да ги получаваме отвън. Ако нашия клас има нужда от място, където да пише информацията, това място да идва отвън. Ако направим това нещо, спазваме и втория принцип, защото така ще позволим от вън да получаваме най-различни неща, които да ни свършат работа. Така нашия код става преизползваем и комбиниран с всякакви възможности. Примерно ако направим един pdf creator, който трябва да си изпише pdf-a някъде. Ако направим да го изписва винаги на конзолата, то той е обвързан. Ако направим този creator да записва резултата някъде, давайки му някакъв интерфейс, тогава отвън може да определим точно къде - файл, принтер, мрежата и тн.
С други думи, dependancy-тата трябва трябва да се подават отвън.
# Misc
Code debt - термин в програмирането, когато правим некачествен код, защото бързаме. Теглим кредит от качеството на кода. Колкото повече неглижираме качеството, дълга расте. Трупат се лихви, лихви върху лихвите и тн.

Разликата между SOLID принципите и дизайн патърните е че SOLID принципите ни дават насока към която да се стремим, нещо по абстрактно, a дизайн патърните е конкретен проблем с конкретно решение, често срещан проблем с често срещано решение. С други думи, патърните дават вече конкретно измислено решение на проблем, докато при SOLID принципите нещата са по общо казано, какво е хубаво да се прави и да се стремим да го следваме, но не е конкретно решение.

# ChatGPT

# Bookmarks 
[Clean Code: A Handbook of Agile Software Craftsmanship: Robert C. Martin: 9780132350884: Amazon.com: Books](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) 
