# General
## Dependency Inversion
Спазването на dependency inversion - петия принцип от SOLID, освен че ни дава възможност да разширяваме много кода, получаваме възможност да го тестваме много лесно и да му контролираме поведението, докато го тестваме. Като вторична полза от този принцип е че тестовете могат да бъдат много по всестранни и могат да бъдат много по лесно контролирани неговите dependency-та. Dependency e и ключовата думичка `new` - това е все едно да оженим един клас за друг и нямат разкачане. 

Ако имаме следния код:

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240721134431.png)

`Bank` и `AccountManager` класовете, са много тясно свързани и банката не може без акаунт мениджъра. От тази връзка, следват различни следствия - ако се появи бъг в акаунт мениджъра, той се пренася и в банката. Друго следствие е, че ако искаме да тестваме банката, трябва да тестваме и акаунт мениджъра заедно с нея. Ако акаунт мениджъра е завързан за външен ресурс, банката се завързва и с него. Примерно ако акаунт мениджъра използва база данни, за да тестваме банката, трябва да имаме базата данни налична. Тази тясна връзка си проличава много силно, когато тръгнем да тестваме, защото unit test-a е длъжен да подсигури всяко външно депендънси, което акаунт мениджъра има - не може изолирано да тестваме поведението само на банката, абстрахирайки се от какво прави акаунт мениджъра конкретно. Това е силно депендънси и се стараем да го избягваме, когато е възможно.

Когато искаме да разкачим дадени класове, най-лесната връзка, която може да направим между тях е чрез интерфейс. Примерно да направим мост между банката и акаунт мениджъра `IAccountManager` или нещо, което да е абстрактно. Когато банката зависи от интерфейса, в unit test-a може да подадем какъвто си искаме акаунт мениджър, който може да е създаден само за целите на unit test-a и така напълно да контролираме неговото поведение. Така тестваме само поведението на банката, без акаунт мениджъра да влияе и евентуални негови бъгове, няма да се пренесът на банката. Акаунт мениджъра трябва да се провери с други unit тестове, които ще проверяват само неговото поведение. Unit тестовете, които тестват банката, ще се занимават само с нейната функционалност, без евентуалните проблеми на акаунт мениджъра да се пренасят върху нея.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240721145552.png)

Банката си получава това депендънси отвън, затова казваме dependency inversion - зависимостта на банката вече не идва от самата банка, но отвън, тоест обръщаме наопаки нещата. Така може да си позволим лукса - отвън да получим всякаква имплементация на акаунт мениджъра и тя да бъде каквато решим. В unit test-а ще е една, в реалността ще е друга, в друга ситуация ще е съвсем друга за целите на съответната програма, важното е че получаваме гъвкавост.

Когато правим тестове с наш акаунт мениджър, който сме написали, ние може да видим примерно как реагира банката, ако акаунта не съществува - като на акаунт мениджъра му се поиска акаунт, той да връща null. Така ще разберем дали банката се държи адекватно в тази ситуация. Друг вариант ако акаунт мениджъра върне два акаунта с един и същи номер и тн. Тази гъвкавост в тестването я постигаме спазвайки dependency inversion принципа.

Примерно, ако имаме следните класове:

```
namespace MockingAndTestDrivenDevelopment
{
    public class GreetingWriter
    {
        public void WriteGreeting()
        {
            if (DateTime.Now.Hour < 12)
            {
                Console.WriteLine("Good morning!");
            }
            else if (DateTime.Now.Hour < 17)
            {
                Console.WriteLine("Good afternoon!");
            }
            else
            {
                Console.WriteLine("Good evening!");
            }
        }
    }

    public class Program
    {
        public static void Main()
        {
            var writer = new GreetingWriter();
            writer.WriteGreeting();
        }
    }
}

//Tests Project

namespace MockingAndTestDrivenDevelopment.Tests
{
    public class Tests
    {
        [Test]
        public void WritGreetingShouldWorkCorrectlyInTheMorning()
        {
            var writer = new GreetingWriter();
            writer.WriteGreeting();
            // Assert? contains 'morning'?
        }
    }
}
```

При така написаните неща, няма как да направим Assert-a, защото метода не връща нищо, а не може да прочетем какво пише на конзолата. 
Другия основен проблем е че за да вземем поведението му сутрин, трябва да го стартираме сутринта. Тези проблеми, когато нещо не може да бъде проверено или условията му не зависят от нас, означава че  dependency inversion принципа не е спазен. 
В случая горе имаме две основни депендънсита - едното е върху `DateTime` , която е статична информация, която се сменя и ние  не може да я контролираме. Второто депендънси е конзолата. Двете неща едновременно ни пречат да напишем тест. Примерно искаме да разберем дали текста съдържа `morning`, но няма как да го направим. Трябва да изнесем депендънситата отвън. 
Проблема с времето може да разрешим по два начина - да направим `ITimeProvider` интерфейс, който да има метода `GetTime()` или когато е само една единствена информация, може директно да я изнесем навън - да подадем на метода `WriteGreeting(DateTime dateTime)`. Който ще ползва метода, трябва да подаде времето спрямо което трябва да се изчисли поздрава. 
Минуса при dependency inversion-a e че трябва тази информация да се даде отвън. За улеснение на хората, които ползват кода, може да направим метод overloading - тоест същия метод, без параметри, който да извика другия метод с default стойността. Тази стойност не може да се подаде при параметрите като default защото е динамично променяща се.

```
public void WriteGreeting(DateTime dateTime) {..}

//TestProject

namespace MockingAndTestDrivenDevelopment.Tests
{
    public class Tests
    {
        [Test]
        public void WritGreetingShouldWorkCorrectlyInTheMorning()
        {
            var writer = new GreetingWriter(new ConsoleWriter());
            writer.WriteGreeting(new DateTime(2021, 1, 1, 8, 0, 0));
            // Assert? contains 'morning'?
        }
    }
}
```

Тази корекция в проекта решава първия проблем, но втория къде точно информация се изписва не е решен. Примерно ако утре има изискване поздрава да се изписва във файл или да се праща по мейл, така както е, не може да стане. Трябва да копираме `GreetingWriter` и да направим `GreetingFileWriter`, `GreetingEmailWriter`, `GreetingConsoleWriter` и тн.
Този подход е крайно нежелателен, трябва да се изкара и второто депендънси отвън чрез интерфейс, който да има метода Write.

```
namespace MockingAndTestDrivenDevelopment
{
    public interface IWriter
    {
        void Write(string text);
    }
}
```

Благодарение на този интерфейс, може да си направим различни класове, които да го имплементират и те да изписват информацията там където трябва.
Трябва да направим конструктор, който да приема `IWriter` и да го записва в поле вътре в класа. След това трябва да заместим този writer вместо конзолата. Правейки си `ConsoleWriter` клас, който да имплементира `IWriter`, запазваме оригиналната функционалност да пише на конзолата.  
Може да си направим и `PrettyConsoleWriter` клас, който да имплементира `IWriter`, като в този клас, пак ще изписваме текста на конзолата, но с добавени тирета. 
Направихме си различни writers, които може да бъдат използвани в комбинация с нашия `GreetingWriter`, при създаването му. Това ще определя къде той ще пише, тоест даваме му това депендънси - за писане. Може да си направим и празен конструктор, който да подава `ConsoleWriter` към другия конструктор. Старото поведение си остава, но даваме възможност, от вън да ни вкарат друг writer.

Сега вече, може да си направим наш специален `MemoryWriter`, който да използваме за unit test. Неговата единствена цел ще е да събира в string builder това което write метода изписва.  Може да override-нем метода `ToString()` и да връщаме съдържанието на string builder-а. Така спазваме и open close принципа - без да пипаме `GreetingWriter` му направихме нов writer. Сега вече имаме какво да assert-нем, може да направим променлива от тип `MemoryWriter` и да я подадем като аргумент на `GreetingWriter` в unit test-a. След като изпълним метода `WriteGreeting`, може да извикаме в assert-a `ToString()` метода на memory writer променливата и да проверим дали съдържа очаквания резултат.

Кода ни след промените изглежда така:

```
using System.Text;

namespace MockingAndTestDrivenDevelopment
{
    public interface IWriter
    {
        void Write(string text);
    }

    public class ConsoleWriter : IWriter
    {
        public void Write(string text)
        {
            Console.WriteLine(text);
        }
    }

    public class PrettyConsoleWriter : IWriter
    {
        public void Write(string text)
        {
            Console.WriteLine(new string('-', 60));
            Console.WriteLine('-' + text + new string(' ', 60 - 2 - text.Length) + '-');
            Console.WriteLine(new string('-', 60));
        }
    }

    public class MemoryWriter : IWriter
    {
        private StringBuilder sb = new StringBuilder();

        public void Write(string text)
        {
            sb.AppendLine(text);
        }

        public override string ToString()
        {
            return sb.ToString();
        }
    }

    public class GreetingWriter
    {
        readonly IWriter writer;

        public GreetingWriter()
            : this(new ConsoleWriter())
        {
        }

        public GreetingWriter(IWriter writer)
        {
            this.writer = writer;
        }

        public void WriteGreeting()
        {
            WriteGreeting(DateTime.Now);
        }

        public void WriteGreeting(DateTime dateTime)
        {
            if (dateTime.Hour < 12)
            {
                writer.Write("Good morning!");
            }
            else if (dateTime.Hour < 17)
            {
                writer.Write("Good afternoon!");
            }
            else
            {
                writer.Write("Good evening!");
            }
        }
    }

    public class Program
    {
        public static void Main()
        {
            var consoleWriter = new GreetingWriter(new ConsoleWriter());
            consoleWriter.WriteGreeting(DateTime.MaxValue);

            var prettyConsoleWriter = new GreetingWriter(new PrettyConsoleWriter());
            prettyConsoleWriter.WriteGreeting(DateTime.MinValue);
        }
    }
}

//Tests Project

namespace MockingAndTestDrivenDevelopment.Tests
{
    public class Tests
    {
        [Test]
        public void WritGreetingShouldWorkCorrectlyInTheMorning()
        {
            var memoryWriter = new MemoryWriter();
            var writer = new GreetingWriter(memoryWriter);

            writer.WriteGreeting(new DateTime(2021, 1, 1, 8, 0, 0));

            Assert.True(memoryWriter.ToString().Contains("Good morning!"));
        }
    }
}
```

Това е цялата идея на използването на dependency inversion и как той помага при писането на тестове.
## Mocking
Симулиране поведение на реални обекти.
Използва се почти винаги в unit тестове.
Runtime създава клас, който не го виждаме, докато теста работи. В този клас, може да променим поведението на даден метод или методи и след това да създадем обект от него. С други думи, по даден интерфейс да ни направи клас, който не съществува в кода освен при изпълнението на теста и да може на този безимен клас да променяме поведението на метод или методи и да игнорираме останалите и ги оставяме празни. 

Използва се за да подсигури някакво депендънси - ако обект има нужда от някакво време, работа с мрежа, с файл или каквото и да е зад което стои интерфейс. Когато даден метод, клас, функционалност и тн има нужда от интерфейс, тогава може да му предоставим мокинг обект, който сме си го измислили, създали и написали само в рамките на unit теста и само и единствено за неговите цели. 
### Moq Library
Мокинга е направен с много рефлекшън и неговата библиотека е `Moq`, която се намира в NuGet и трябва да я инсталираме. Даваме й интерфейса, който искаме, след това определяме кой метод с каква функционалност да го заменим и накрая искаме от библиотеката да ни направи обект, който да използваме на мястото на интерфейса. Примерно в `GreetingWriter` класа горе в примера, имаме нужда от `IWriter` и казваме на библиотеката, че искаме `IWriter` на който метода `Write()` да пише в определен string, който сме създали в unit теста и накрая искаме обект от това нещо. В `GreetingWriter` даваме несъществуващ клас към момента на писане на кода, който ще се появи, когато стартираме теста и ще бъде от няколко реда. Ще може да му определим поведението, което може да бъде различно за всеки тест. В Moq библиотеката имаме класове, които да ни помагат да създаваме fake обекти, докато нашия код работи. След като го получим като обект:

```
[Test]
public void WritGreetingShouldWorkCorrectlddy()
{
    var myWriter = new Mock<IWriter>();
    var writer = new GreetingWriter(myWriter.Object);

    writer.WriteGreeting(new DateTime(2021, 1, 1, 23, 0, 0));

    Assert.True(myWriter.ToString().Contains("Good evening!"));
}
```

Казваме му да ни направи някакъв клас, който имплементира `IWriter`, прави го с голяма рефлекшън "магия", прави клас, който не е съществувал в кода, прави го да  имплементира `IWriter`, създава необходимите методи, които му трябват и накрая прави от този клас (който не виждаме защото съществува само runtime) инстанция, чрез пропъртито `Object`.
По този начин, може да кажем на този `myWriter` определени методи, примерно метода `Write()`, без значение какъв параметър ще ти подадат, искам да вършиш нещото, което ще напишем в кода, тоест даваме поведение на метода `Write()`. Може да си направим и един string result, където да запишем резултата.

```
[Test]
public void WritGreetingShouldWorkCorrectlyInTheMorning()
{
    string result = null;
    var myWriter = new Mock<IWriter>();

    myWriter.Setup(x => x.Write(It.IsAny<string>()))
        .Callback((string s) => result = s);

    var writer = new GreetingWriter(myWriter.Object);

    writer.WriteGreeting(new DateTime(2021, 1, 1, 8, 0, 0));

    Assert.True(result.Contains("Good morning!"));
}
```

Вместо `Callback()` може да му дадем какво да връща, ако връща някаква стойност или да хвърля exception, изцяло може да му контролираме поведението.

`var myWriter = new Mock<IWriter>();` - искаме "fake" клас, който да имплементира `IWriter`.

`myWriter.Setup(x => x.Write(It.IsAny<string>()))` - в `Setup()` метода, избираме конкретен метод и какви параметри  може да получи в случая това е метода `Write()`. Може да кажем - ако получи даден аргумент, да има даденото поведени в `Callback()` метода. По този начин, може да изредим различни поведения, спрямо различните възможни аргументи. `It.IsAny<string>())` означава, независимо какъв string аргумент получи метода `Write()`, винаги да има определеното поведение:

```
 myWriter.Setup(x => x.Write("Test!"))
    .Callback((string s) => result = s);
 myWriter.Setup(x => x.Write("Test2!"))
   .Callback((string s) => result2 = s);
```

Ако имаме повече от един `Setup()` метода, ще се изпълни първо този, който е най-специфичен, без значение в какъв ред са изредени. Ако не се подаде очакваната стойност, ще се изпълни най-общия `Callback()`:

```
myWriter.Setup(x => x.Write(It.IsAny<string>()))
    .Callback((string s) => result = s);
myWriter.Setup(x => x.Write("Test!"))
  .Callback((string s) => result2 = s);
```

Ако имаме специфичност на еднакво ниво - два еднакви `Setup()` метода, ще се изпълни `Callback()` метода на последния:

```
myWriter.Setup(x => x.Write(It.IsAny<string>()))
    .Callback((string s) => result = s);
myWriter.Setup(x => x.Write(It.IsAny<string>()))
.Callback((string s) => result2 = s);
```

Както `Setup()` така и `Callback()` се дават с ламбда изрази. `Callback()` - реално е анонимния метод, който ще бъде извикан, ако някой подаде очаквания аргумент в `Setup()`.

Когато тестваме база данни, не може да разчитаме че тя ще е налична и затова трябва да я заместим с мокинг. Симулирайки нейното поведение, можем да тестваме важната функционалност на кода. Едно web приложение, обикновено бърка в няколко таблици, вади някаква информация и после я преработва. Нашата задача е да тестваме дали преработването на информацията е ок. Мокинга ни спестява нуждата да вдигаме база данни, да изредим самите данни, да създадем таблиците, да вържем приложението към тази база и чак тогава да пуснем теста. Това е депендънси, което без мокинг, теста трябва да подготви.
## Testing Practices
### Code First
Това е най-често срещания подход в практиката - пишем код и след това правим тестовете за него.
### Test First - Test Driven Development (TDD)
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240723152215.png)

Пишем закоментиран списък от тестове, след това избираме един от тях и го описваме, както и създаваме метода, който ще тестваме, но без поведение.
Компилираме кода и той няма да работи, защото метода не е дописан. 
Следващата стъпка е да напишем кода в метода, за да може да се компилира, но все още не е дописан, затова теста е неуспешен.
След това, дописваме кода, така че да мине теста и махаме повторението на кода, тоест ако се налага да рефакторираме.
Тези стъпки се повтарят за всеки тест. 

Валиден подход е и ако напишем няколко или дори всички тестове наведнъж, след това си написваме кода и проверяваме дали написания код, минава тестовете.
По този начин работим и с Judge системата - има написани тестове, които проверяват нашия код, дали е написан коректно.

Този подход е за предпочитане, когато пишем нещо по-сложно, с цел да имаме някакво подсигуряване. Когато пишем първо тестовете, чисто психологически сме по склонни да намерим евентуални бъдещи проблеми и така шанса за грешка е по-малък. Общоизвестно, че програмистите не са склонни да си намират сами грешки в кода. Когато пишем кода и след това тестовете, подсъзнателно пишем тестове, които да минат върху този код. Поради тази причина, е добре ние да пишем кода а друг да пише тестовете.
## Myths and Misconceptions
Няма как да покрием нищо на 100%, винаги се правят приоритетните тестовете. Дори да имаме 100% code coverage, това не означава че сме покрили всички възможности.
Чрез unit тестовете, може да си отговорим какво искаме този код да прави. 

Тестовете дават добра документация какво трябва кода да прави и как се използва. Спецификацията какво трябва да прави метода в дадена ситуация и как да реагира, е декларирана чрез теста. Но това не е напълно достатъчно за да покрие спецификациите на дизайна.

Unit тестовете сами по себе си, не са достатъчни, трябват и много други тестове. Даден метод може да работи перфектно, но комбиниран с нещо друго, да спре да работи.

TDD също не е достатъчно и не ескалира - не работи в огромни обеми и мащаби. 
Когато пишем тестове, тестовете се качват заедно с кода в repository-то и колегите имат достъп до тях. Всеки път когато качваме даден код някъде, автоматично всички тестове се изпълняват.  При всяка промяна в кода, автоматично тестовете се изпълняват отново. Идеята е, че тестовете живеят не само при нас, но и на сървърите, където сме качили кода. Когато пуснем даден код, преди той да влезне във фирмения код, минава code quality static analysis, минава unit тестовете и ако всичко е ок, накрая обикновено двама колеги, преглеждат кода и връщат feedback и го приемат да влезне официално в целия код на фирмата или го връщат за промяна.
# Misc
## NuGet
Това е огромен списък от библиотеки, които може да бъдат използвани в почти всяко едно .NET приложение, без значение дали е web, desktop, console и тн. Тази галерия от библиотеки е подържана от MS и има около 300000 packages / библиотеки. Има библиотеки за каквото ни хрумне, някои са платени, други са безплатни. Примерно ако искаме да изпращаме emails има много библиотеки, сред които `SendGrid`. Може да качваме и наши библиотеки. Ако искаме да използваме такава библиотека, отиваме на проекта и даваме десен бутон върху Dependencies -> Manage NuGet Packages -> Browse, така се отваря търсачка към галерията. Може да видим и другите инсталирани библиотеки. След като инсталираме дадена библиотека, тя става част от нашия проект. Тя става част от нашия проект по същия начин, ако я имахме локално и я бяхме добавили чрез `Add Project References`. След като я имаме инсталирана, вече може да я ползваме. В една библиотека има стандартните неща, които си правим и ние - класове, интерфейси, структури, enum и тн - функционалност, код, класове, методи, пропъртита, конструктори, които вършат някаква работа. 
## Framework
Framework-a се състои от много библиотеки - примерно, ASP.NET или .NET
В рамките на една библиотека, обикновено имаме много namespaces, но не е задължително.
В един namespace, имаме много на брой класове.
## PHP / WordPress
PHP е много стар език и е много популярен заради WordPress - платформа с която се правят сайтове с PHP много лесно. Стават бързо и е удобно за обикновени информационни сайтове, но не и за по-сложни неща на които е трудно да им се промени основната функционалност. Много от сайтовете в световен мащаб са правени по този начин.
## Compile time / Runtime
Compile time е всичко което се случва, преди да стартираме кода. Компилатора чете кода и създава от него друг код. 
Runtime е когато стартираме кода, докато програмата работи - от влизането в `Main()` до излизането от него.
# ChatGPT
# Bookmarks
https://fontawesome.com/ - всякакви иконки за web проекти, препоръчан от Николай Костов.

[ML.NET - YouTube](https://www.youtube.com/watch?v=dluB5VE1m1k) - какво е AI, Machine Learning, Deep Learning и тн. Хубави дема написани на C# - Николай Костов.

[Николай Костов - ML.NET - Machine Learning за .NET | .NETworking Conference 2023 - YouTube](https://www.youtube.com/watch?v=_1ZMd4vBdmI)

Course completion: 24.07.2024
