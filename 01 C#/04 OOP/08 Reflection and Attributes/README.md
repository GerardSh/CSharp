# General

## Metaprogramming
Програмиране в което използваме информация за дадена програма. Чрез мета програмиране, може да напишем програма, която да работи с информацията, която произтича от кода на друга програма. Мета програми могат да четат инструкциите на други програми и да ги разбират, обработват, разглеждат и да създават мета програми. 
Компилатора е мета програма, защото разбира текста който сме написали и създава програма от него.
Когато се анализира кода и ни се предлага подобрение, също е метапрограмиране. Примерно когато пишем в VS ни подсказва дадени неща като да махнем излишни неща или че трябва да се ползва using и тн.
Рефлешкън е частен случай на метапрограмирането и също е такъв вид, който ни позволява да прочитаме информацията за вече написана програма, тоест какъв е списъка от класове, които са направени и съществуват в нашата програма. Също може да се види какви са методите в даден клас или какви полета има.
Част от метапрограмирането е програма която се само модифицира докато работи
## Reflection
Възможността на даден език за програмиране да разглежда какво съществува в дадена програма. Чрез рефлекшън, може да видим списъка с конструкторите на даден клас и да ги foreach-нем. Може да извикаме даден конструктор или метод, да създадем даден клас, да обходим всички методи и класове и да филтрираме на база определени критерии. Тези неща се случват динамично, докато програмата работи, което е различно от това да напишем някакъв код и да го пуснем. Програми които разбират какво е написано в тях, програми които могат да разгледат информацията за самите себе си.

Примерен код, как може да извлечем информация за методите в даден код, ползвайки рефлекшън и извиквайки определен метод:

```
public class MyClass
{
    public int MyProperty { get; set; }

    public void MyMethod()
    {
        Console.WriteLine("MyMethod");
    }

    public void Mymethod2()
    {
        Console.WriteLine("MyMethod2");
    }
}

public class Program
{
    public static void Main()
    {
        MyClass myClass = new MyClass();

        var myClassMethods = myClass.GetType().GetMethods();

        foreach (var method in myClassMethods)
        {
            Console.WriteLine(method.Name);

            if (method.Name == "MyMethod")
            {
                method.Invoke(myClass, null);
            }
        }
    }
}
```

Ако искаме просто да си извикаме даден метод и го знаем какъв ще бъде, просто го извикваме без рефлекшън. Рефлекшън ползваме, когато името на метода идва от вън и е като стринг или искаме да направим няколко проверки преди да извикаме метода и не знаем как се казва. 
Рефлекшън не може да бърка в чужд код - който не е .NET или до който нямаме достъп.
### Use Cases
Може да вмъкваме нови парчета функционалности (DLL's / Assembly's) - plugins.
Може да генерираме код или да спестяваме генерирането на код.
Концепцията за mapping e нещо от един клас с едни пропъртита прехвърля информацията в друг клас със същите пропъртита
Когато искаме да прочетем дадена програма и нейната информация вътре в нея, какви класове и методи и тн има. От тази информация се възползва Unit testing-a.
Unit testing-a е когато създаваме много методи и всеки един от тях представлява отделен тест. Теста се стартира, проверява се какво прави и ако всичко е коректно, се маркира като ок. Ако получи грешна информация, теста гърми. Unit test технологиите използват този принцип, минават, разглеждат кода, намират тест методите и ги извличат и стартират само тях. След това ги пускат и гледат дали работят коректно или не, накрая ни казват резултата.

Вид рефлекшън е и когато имаме код във формата на стринг, написан от потребителя или прочетен от някъде, от който да направим програма.

В практиката на junior програмистите, не ни се налага да пишем рефлекшън. Всяко нещо което бихме искали да ползваме свързано с рефлекшън, вече е написано. Технологиите които ще използваме ползват рефлекшън, но на нас не би ни се наложило да го пишем.
### When not to use
Ако може да не го използваме, не го ползваме. С други думи не го ползваме никога, освен ако не се наложи.
Примерно ако знаем как се казва метода, го извикваме директно. Едно и също действие да извикаме даден метод, ползвайки рефлекшън отнема много повече редове код и е няколко пъти по-бавно. Ако потребителя отвън ще казва името на метода, по динамично е да се ползва рефлекшън, но би могло да стане и с if проверки.
Друг минус на рефлекшън е, че чупи концепцията за енкапсулация, защото не се интересува от модификаторите за достъп и може да пипа private членове в други класове. 
## Type Class
В типа данни Type се съхранява информацията за типовете данни.
Взимането на Type е много важно, за да може да продължим работата с рефлекшън.
За да получим типа данни, първия вариант е по време на компилация когато ни е известен типа данни, който искаме да проверим.

Тогава ползваме ключовата думичка `typeof()`

`Type type = typeof(Person)` ако искаме да разгледаме класа `Person`

Втория вариант да вземем данните е когато знаем типа данни като стринг:

`Type type2 = Type.GetType("ReflectionAndAttributes.Person");` `ReflectionAndAttributes` е името на namespace-a.

Този подход е много мощен и се ползва често. Той ще вземе типа на класа, без да е ясен по време на компилация, понеже стринга може да дойде отвънка.

Третия вариант е когато имаме променлива и искаме на променливата да вземем типа:

`Type type3 = person.GetType()`

Има много информация която може да видим за даден клас, примерно кой е неговия базов клас или какво интерфейси имплементира.
Може да попитаме дали даден тип данни е интерфейс или клас, или абстрактен клас.
Може също да проверим дали даден клас е статичен, като проверим дали типа е abstract и sealed.

За да проверим за private полета, трябва да ползваме метода `GetFields()` с двата параметъра в кода долу, ако ни трябват публичните полета, няма нужда от параметри. Тези методи връщат публичните неща по default, ако няма параметри.
Чрез този метод виждаме и скритите полета на автоматичните пропъртита, които не се виждат в написания от нас код. В процеса на компилация, нашия код се превежда на междинен език и автоматични неща като тези пропъртита се разпъват и от един ред пропърти става на get и set методи и private поле.

```
Type type = typeof(Person);
var fields = type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);

foreach (var field in fields) 
{
    Console.WriteLine(field.Name);
}
```

Ако искаме да получим всички възможни полета трябва да напишем:

`var fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);`

`BindingFlags` е enum.

След като получим поле, може да проверим какъв тип е, дали е публични, дали е инстанционно и тн 
## Type Assembly
Този тип данни е над Type и ни дава възможност да вземем информация за цялото assembly:

```
Assembly assembly = Assembly.GetExecutingAssembly();
Console.WriteLine($"Current project is {assembly.GetName().Name} and has {assembly.GetTypes().Count()} classes");
```
## Creating New Instances Dynamically
Може да създаваме инстанции от променлива тип Type. Ползва се статичния метод `Activator.CreateInstance()` който връща object.

```
Type type = typeof(Person);
var person = Activator.CreateInstance(type);
```

Трябва да го кастнем към правилния тип данни, за да може да ползваме пълната функционалност на дадения тип.
Ако типа Person в примера, няма празен конструктор, кода ще гръмне по време на runtime. Трябва да му дадем списък с аргументи: 

` var person = Activator.CreateInstance(type, 5);`

Двата реда са идентични:

```
Type type = typeof(Person);
var person = Activator.CreateInstance(type, 5) as Person;
var person2 = type.GetConstructor(new Type[] { typeof(int) }).Invoke(new object[] { 5 }) as Person;
```

`type.GetConstructor(new Type[1] { typeof(int) })` - определя колко параметъра и от какъв тип има в конструктора с който искаме да направим обекта. Може и да не посочваме броя на параметрите, а само да ги изредим.
## MethodInfo Type
Това е тип, който съдържа информацията на даден метод.
Когато сме намерили даден метод, може да го извикваме с метода `Invoke()` - където като параметри, трябва да посочим обекта върху който да се изпълни и списъка с параметри. Ако няма параметри, се слага null.

```
Type type = typeof(Person);

MethodInfo myMethod = type.GetMethod("MyMethod");

var person = new Person();

myMethod.Invoke(person, new object[] {5});
```
## Access Modifiers
Всички членове в един клас, както и самия клас, имат следните пропъртита:

![](Pasted%20image%2020240709154738.png)

# Misc

# ChatGPT

# Bookmarks 
Лекция за по-напреднали, част от курса за C# Masterclass

[Бонус: Reflection за напреднали - Софтуерен университет](https://softuni.bg/trainings/resources/video/66659/bonus-advanced-reflection-csharp-oop-october-2021/3484)

[C# Masterclass - Reflection - октомври 2019 - Николай Костов - YouTube](https://www.youtube.com/watch?v=LkWis2vrUIE&t=6s)
