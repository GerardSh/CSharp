# General
Масивите са базова колекция и са бързи. 
Индексацията им винаги започва от 0 и завършва на Length-1.
Елементите са винаги от един тип, примерно integers. При декларация, задължително трябва да укажем неговата големина и вид. Въз основа на това, веднага се заделя последователна памет толкова байтове, колкото е нужно. Примерно, ако кажем че искаме масив от 4 int-a, то всеки от тях има 4 байта, което означава 16 байта заделена памет.
Деклариране или по скоро алокиране (запазване) на памет за масив от 5 int елемента:

```
int[] masiv = new int[5];

// добавяне на литерали, тоест стойности които за директно вкарани в кода, а не подадени от вън.
int[] masiv = new int[5] { 1, 3, 6, 8, 25 };

// когато имаме литерали, може да ги запишем и така:
string[] array = 
{
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday"
};
```
Ако сме задали литерали, може и да не слагаме големина на масива, той сам ще ги изчисли.

Всички елементи на масива имат начална стойност, стойността по подразбиране на дадения тип.

foreach е read only - това означава, че не може да променим стойността на дефинираната променлива в скобите на цикъла, в примера долу, number. Предимството му е, че обхожда целия масив, без риск да излезе от неговите граници. 
Цикъла работи като първо прочита стойността на даден елемент в дефинираната променлива, така че дори да променим елемента в тялото на цикъла, това няма да промени стойността на прочетената променлива.

```
int[] numbers = { 2, 4, 5, 6, 7 };

foreach (int number in numbers)
{
    Console.WriteLine(number);
}

```

# Misc
Ако искаме да разделим стринг, трябва да използваме сплит метода и да посочим критерия за разделител. По default е празни полета. Ако този критерии се съдържа два или повече последователни пъти, то всеки следващ бива записан като празен елемент в масива:
```
// получаваме масив с 3 елемента един от които празен.
string[] test1 = "123testtest123".Split("test");
// изтрива празните ентрита
string[] test1 = "123testtest123".Split("test", StringSplitOptions.RemoveEmptyEntries)
```
Веднъж split-нат стринга, вече имаме array и може директно да го запишем във стринг масив или дори да ползваме някой от елементите му за да запишем в нормален тип данни.
```
double test = double.Parse("123test123".Split("test", StringSplitOptions.RemoveEmptyEntries)[0]);
```
След като това този масив може да го трансформираме, ползвайки select метода, примерно да парснем всеки елемент в double, но върнатия резултат вече не е масив и трябва да ползваме `ToArray()` метода. Select минава през всеки един елемент от колекцията и изпълнява действие върху него. Ако имаме Select(Double.Parse) double.parse , тоест подаваме метод към друг метод, това се нарича делегат.. Той е отговорен да извика метода върху всеки един елемент от колекцията, когато му потрябва. Ако сложим скобата на метода, то това означава че го извикваме на момента.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240109224417.png)

Проблема е че метода селект връща Enumerable, което означава просто колекция, нищо повече. Тази колекция, трябва да я превърнем в масив и да я запишем там. Това става чрез ToArray() метода.

1. **Split:**
`Split` breaks the original string into an array of substrings based on a specified delimiter.
The result is an array of strings.
2. **Select:**
`Select` is then used to transform each element of the array (each substring) into a new value.
The transformation in this case involves parsing each string element into a `double`.
 The result is an `IEnumerable<double>`, which is a sequence of transformed elements.

So, `Split` creates an array, and `Select` transforms each element of that array into a sequence of new elements. The use of `IEnumerable<double>` allows for further manipulation and processing of the transformed elements without the need to immediately convert them into an array. This supports deferred execution and provides flexibility in working with the data.

Процедурно програмиране е когато се задава стъпка по стъпка какво трябва да се случва в програмата до получаване на резултат.
Функционалното програмиране се задава какъв резултат искаме и то се случва. Води се по скоро декларативно и ние казваме какво искаме да постигнем, а не как това да се случи.
Systemlink е функционално програмиране вътре в C# и работи единствено с колекции, от които масивите са част.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240109214356.png)

ключето означава пропърти на обекта.
кубчето е метод, тоест действие което въпросния обект може да изпълнява.
кубчето със стрелка са екстеншън методи, те не са част от самия масив, а идват от библиотека, някой ги е написал допълнително и да ги закачи към масива за да може да ги ползваме.
Това което е отбелязано със звездичка е избор на AI кое според него бихме искали в момента да ползваме.

Основните градивни единици на един клас са неговите свойства и методи. 
Примерно човека е обект, има свойства като име, възраст, цвят на косата, всякакви характеристики. А това което може да прави, като да говори, да пише, да рисува.. са все действия, все едно методи. Свойствата характеризират обекта, а методите извършват действия.

Чрез string.Join("",) обръщаме елементите в стринга и им слагаме сепаратор какъвто решим, на мястото на спейсовете:

```
string test = "10 20 30 40";
int[] arr = test.Split(" ",StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToArray();

Console.WriteLine(string.Join("", arr.Reverse()));
```

string.Join() очаква като стойност enumerable sequence и ги свързва с посочения символ в кавичките. Горния код работи, защото Reverse() връща enumerable sequence. 

# Bookmarks 
[Longest Increasing Subsequence - YouTube](https://www.youtube.com/watch?v=TB7ZXhNXh0U&t=130s) Ивайло Кенов, обяснява последната задача. 
