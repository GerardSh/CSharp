# General
Метода е именувано парче код, което може да бъде извикано и получава някакви данни, обработва ги по зададен начин и връща резултат. 

Метод и функция е едно и също.

Понеже Main метода е статичен, вътре може да се ползват само статични методи.

Имената на методите са паскал кейс. Тялото на метода е оградено с къдрави скоби.

Invoking (calling) the method, може да бъде безброй пъти. Вместо да пишем едно и също нещо, просто викаме метода. Един от най-важните принципи при програмирането е DRY - do not repeat yourself.

Всеки метод трябва да решава не повече от една задача.

Използваме методи, защото разделя големи проблеми, на малки парчета. Също ако има допусната грешка вместо да се поправя на всички места, където е ползван метода, се оправя само на едно място. Или ако се добавя нов feature.

Когато декларираме един метод, точно преди името, трябва да сложим типа на върнатия резултат. Методите които не връщат резултат след обработката на данните се слага Void. Console.WriteLine() е пример за такъв метод, който не връща резултат, а само изпълнява действие да отпечата на конзолата. Console.WriteLine() връща string.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240120211013.png)

Преди static, има модификатор за видимост на метода, ако е изпуснат по default е private.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240120225140.png)

Параметрите се виждат само в scope-a на метода.
Извикването на метода и неговото изпълнение става чрез писане на неговото име и кръгли скоби. Ако метода има параметри, трябва да ги попълним, ако няма - остават празни.

Рекурсия е когато метода вика сам себе си.

**VALUE TYPES**

Променливите задържат директно тяхната стойност. Това са простите типове, на които знаем точния размер - int, float, double, bool... пазят се в Stack. Ако имаме променлива int n = 6 - то в стека се отделят 4 байта и стойността се записва директно там. 
Всяка променлива си има собствено копие на стойността , тоест:

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240121234309.png)

въпреки че б = а, то б си е запазило собствената стойност, дори след като а се е променила.

**REFFERENCE TYPES**

Това са string, всичките масиви и тн. Стойността по подразбиране е  Null. Проблема е че не е ясно колко памет трябва да се запази, а стека е малък. Heap-а е по-голямата част от паметта. В стека се запазва адреса на стойността, който се намира в хийп-а. Когато се извършва присвояване от една променлива на друга, то тя получава само адреса в стека и ако се извърши някаква промяна върху съдържанието в хийп-а, то тази промяна е видима и в двете променливи.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240121235515.png)

StringBuilder - ползваме се защото стринга по принцип е immutable, което означава, че ако се направи промяна във стринга, то трябва да се създаде нов стринг в паметта. Ако имаме много промени, това натоварва паметта значително и става бавно. В тези случаи се ползва StringBuilder, който акумулира в себе си информацията за въпросните стрингове, но резултата накрая, ще бъде калкулиран, само когато го поискаме. Стойността му не е immutable и може да бъде променяна. 

**SIGNATURE AND OVERLOADING**

Комбинацията от името и параметрите на метода са неговата сигнатура. Не можем да имаме два метода с еднаква сигнатура. Може да имаме с еднакво име, но тогава трябва да са различни параметрите, и то не името им, а вида или позицията. Може да имаме с еднакви параметри, но трябва да сменим името. 
Методите с едно име, но различна сигнатура, се наричат overloading. За да може да имаме overloading, трябва да имаме и дефиниран клас, защото по default слага методите в unnamed global namespace.

**CALL STACK**

Тука се записват методите в реда им на извикване, които се редят един върху друг по време изпълнението на програмата. Когато изпълнението на даден метод приключи, той изчезва от стека и компилатора се връща до реда, където се е намирал, преди да влезне с метода. Методите на .NET не ги показва в стека, защото нямаме достъп до тях. Изваждането и на последния метод от стека, води до приключване на програмата.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240122170432.png)

# Misc

Параметрите на метода може да са задължителни или опционални, като вторите, имат зададени стойности по подразбиране, ако не се попълни нищо. Те трябва да стоят след задължителните и задължително да имат някаква зададена стойност, която ще се използва, в случай че не бъде дадена при използването на метода. Параметрите може да получават стойности от константни променливи, но не и от обикновените променливи:

>In C#, method parameters are evaluated at the call site, and the values of variables or expressions are determined at runtime. This is known as late binding or run-time binding.
>When you call a method, the arguments you provide are evaluated before the method is executed. Constants, if used as arguments, are known at compile-time because their values are fixed and don't change during program execution. However, variables can have their values determined only at runtime.

Main метода на всяка конзолна апликация е стартовата точка и от там започва да се изпълнява кода. По default има като параметър string[] args и този масив, може да се напълни като параметри при стартирането на exe-то на програмата през конзолата:

**MyProgram.exe 1 2 3**

Това ще напълни три елемента от този default масив, който е read only, не може да бъде променян след стартиране на програмата и подаване на параметрите през конзолата.

Когато искаме метода да връща някакъв резултат, а не само да изпълнява действие, то тогава трябва да посочим типа на резултата на мястото на void и в тялото на метода трябва да имаме return който да отговаря на посочения тип. 

Опростяване на if проверка, за да не заема много място:

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020240122190240.png)

Най-често кода се пише на куп и после се рефакторира, тоест част от него се изнася в методи, класове и тн.

# Bookmarks 
