# General
CLR - common language runtime.
Int32 е CLR тип, а int ключова дума, която само C# разпознава. Прави се превод от C# към intermediate language (междинен език) и там всички типове са CLR.
.Net разбира само от CLR типове.

**VARIABLES**
Scope - where you can access a variable (global, local).
{ block code scope - променливите живеят само в тоя scope }
Lifetime - how long a variable stays in memory.
Span - колко време преди да ползваме променливата сме я декларирали. Желателно е да се декларира максимално близо до блока от код където се ползва, с цел четимост.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/a/Pasted%20image%2020231228201450.png)
Eдин бит се губи за знак, когато има отрицателни стойности.

![](https://github.com/GerardSh/SoftwareUniversity/blob/main/a/Pasted%20image%2020231228202938.png)
Literal-и наричаме стойностите които даваме в началото на променливите. Литерала може да е от всеки тип - double, integer, bool.. 

`long a = int.MaxValue + 1;` дава грешка, въпреки че искаме да запазим стойността в тип long. Компилатора първо гледа израза отдясно и го събира, но понеже и двете стойности са от тип int и overflow-ва. За да решим проблема, трябва поне един от операндите да има cast или suffix или да е променлива от лонг тип. Така целия израз става лонг и чак тогава се запазва в 'а'.
Типа int32 е default в C#, както и double за дробни числа.

**Type Conversion**
Implicit - скрито конвертиране, C# прави сам, без да ни пита, примерно от int в double или от int в long. Няма стойности от типа int, които да не могат да бъдат записани в long, тогава трябва да се направи експлицитно.
Explicit - означава, че носим отговорност за конвертирането, тоест трябва да сме сигурни, че наличните стойности, могат да бъдат записани в другия тип, без загуба на данни. Прави се като се напише типа в скоби, преди числото: 
```
long number = 7;
int newNumber = (int)number;
```

**Escaping Characters**
`\`
`char test = '\'';`
`\n` - нов ред
`\t` -табулатор, слага няколко спейса в стринг. 
`\0` - празен char

UTF-8 codes за предпочитане се представят с тяхната hexadecimal стойност -
`char test = '\u044F'` е същото като 
`char test = (char)1103;`
Можем да преобразуваме от десетична в hexadecimal
`Console.WriteLine(1103.ToString("x"));`
Стойностите в hexadecimal се дават с едно 0x пред стойността: 
`char a = (char)0x61;`

String
Стринга е масив от чарове и когато записваме даден стринг, C# запазва точно толкова място в паметта, колкото е нужно за да го събере. Ако направим каквато и да било промяна по стринга, C# създава изцяло нов стринг. Това се случва при всяка промяна и е относително бавна операция. Ако има честа промяна, трябва да се ползва конструкцията string builder.
По default стойността е липса на стойност null, защото не се знае колко точно трябва да се запази.

String Verbatim - слага се @ пред стринга и няма нужда да се ползват escaping char. Единствено се налага за кавички и тогава escaping char-a e пак кавички. Може да се комбинира със стринг interpolation.
# Misc
**SCIENTIFIC NOTATION**
double test = 24e+3;
double test1 = 24000;
double test = 1e-3;
double test1 = 0.001;

epsilon - показва допустимата граница от десетични запетаи за две числа да се считат за равни. Примерно ако искаме да проверим до втория знак след десетичната запетая 1.2578 дали е равно на 1.2566 не може да го направим с == защото ще даде false. Трябва да дадем eps = 0.01 и вадим по-голямото число от по-малкото и сравняваме дали резултата е по-малък от  eps. Еквивалента при целите числа е ако искаме да видим дали две числа примерно са еднакви до стотиците, да кажем имаме 100 и 199, епсилон-а ни ще е 100. Изваждаме 100 от 199 и виждаме че понеже резултата е по-малко от 100, значи стотиците са еднакви.
Изразено с код:
```
const double eps = 0.01;

double number1 = double.Parse(Console.ReadLine());
double number2 = double.Parse(Console.ReadLine());
double result = 0;

if (number1 > number2)
{
result = number1 - number2;
}
else
{
    result = number2 - number1;
}

Console.WriteLine(result < eps);
```

# Bookmarks 
