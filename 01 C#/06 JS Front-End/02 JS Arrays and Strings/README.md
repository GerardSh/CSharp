# General
## Arrays
Списъчен тип обекти - еднотипни данни комбинирани заедно. Признака по който комбинираме неща заедно е техния тип.

Те са референтен тип - тяхната променлива сочи към адрес в паметта, където стои този масив.
Паметта е разделена на stack и heap. Stack-a е заделена памет, специално за execution-a нашата програма, лимитиран от няколко мегабайта. В него държим execution context-ите на всички функции, променливите, параметрите, call stack-a с извиканите функции, всички примитивни типове се записват директно в там. Stack паметта е ограничена по размер и обикновено по-бърза, защото е силно организирана и управлявана от компютъра чрез LIFO (last in, first out) подход. 
Когато имаме променлива, която държи примерно масив, в stack-a имаме само референция / адреса, сочещи към heap-a - мястото в паметта, където се намира масива. Heap-a е оперативната памет, която имаме на машината и от нея се заделя място за референтните данни, в нашата програма. Динамични данни като референтни типове данни (например масиви, обекти и други структури, чиито размер може да се променя). Управлението на heap паметта изисква повече време и е по-гъвкаво, тъй като позволява динамично разпределение и освобождаване на памет, когато вече не е нужна. Това е по подобие на pointers в C++ и C. Разликата между референция и pointer е, че pointer-a е действителна променлива, която съдържа адрес в паметта, и можем директно да достъпваме стойността му като число. Можем също така да променяме стойността му, за да посочва към различни адреси, което дава много контрол, но също така изисква повече внимание за избягване на грешки. С pointer-ите може да правим операции, pointer-a си е сам по себе си тип, като например`int*`, `float*` и т.н., докато в JavaScript и C# референциите не се възприемат като отделен тип. Референцията просто сочи към обект в `heap` паметта. Така че, макар да споделят идеята за указване към паметта, `pointers` и референциите са различни в своето предназначение, безопасност и контрол.

Всеки масив си има клетка с индекс започващи от 0, масив от 5 елемента ще има индекси започващи от 0 до 4. Последния индекс на елемента се намира като извадим от общия брой на елементите 1.

Литерала за масив са квадратните скоби `[]`.

Масива в JS прилича повече на List-a в C#, няма нужда да посочваме неговата дължина предварително. Може да си декларираме празен масив и неговата дължина се променя динамично.

Дължината и типа не са фиксирани, може да имаме масив с различни типове данни вътре. Не е добра практика да се смесват типовете данни и трябва да се избягва.

Ако изпишем на конзолата масива, ще покаже стойността на елементите и техния брой.

Може да променим броя на елементите в масива като зададем стойност на `length`. Така ако посочим по-голяма дължина от броя на елементите му, ще добавим празни елементи. Ако посочим по-малка дължина, ще изтрием елементите излизащи от нея.

```javascript
    let array = [];
    array.length = 10;
```

Данните може да бъдат съхранявани в non-conttiguous locations (последователни съседни клетки) в паметта. Примерно първите елементи може да се намират в две клетки, следващите в други клетки на друго място в паметта и тн. С други думи, масива може да бъде разпръснат в различни клети в паметта. Реално за нас е важно като извикаме масива, да го получим, няма значение къде се намира в паметта.
### Dense / Sparse Arrays
Масивите биват dense (плътен) и sparse (разреден). Това са двата вида масива, които може да има в езиците.

```javascript
    let denseArr = [undefined, undefined, undefined];
    let sparseArr = [];
    sparseArr.length = 3;

    console.log(denseArr.length === sparseArr.length);   // true
    console.log(denseArr); // (3) [undefined, undefined, undefined]
    console.log(sparseArr); //(3) […]
```

И двата масива имат три празни елемента, само че dense масива съдържа три последователни стойности, докато sparse масива е празен. `undefined` се явяват реални стойности, които си заемат място, докато при sparse елементите не съществуват на ниво памет. Не всеки език има такова свойство, примерно може да декларираме масив от много елементи, който няма да заема място в паметта. В C# когато декларираме масив, то масива си има строго определен размер, базиращ се на типа данни и броя елементи, което означава че са dense масиви. В JS имаме свойството на sparse масивите, примерно може да имаме първите няколко елемента да са реални а след това да имам дупка от няколко хиляди елемента. 

При обхождане с `for` цикъл или при директен достъп като `sparseArr[i]`, JavaScript ще покаже `undefined` за „празните“ индекси, дори ако те реално не заемат място в паметта.
Това се дължи на начина, по който JavaScript работи със sparse масиви. Някои индекси може да не са заделени, но когато се опитаме да достъпим неинициализиран индекс, JavaScript връща `undefined` като стойност по подразбиране. Този `undefined` обаче не съществува физически в паметта – той е по-скоро логическа стойност, показваща, че няма дефиниран елемент на този индекс.

JavaScript двигателят първоначално ще съхранява масива като dense, ако е възможно. Ако обаче започнем да добавяме елементи на произволни индекси, оставяйки много празни места, масивът може да бъде преобразуван в sparse, което е по-малко оптимизирано за памет и производителност. 
Всеки масив в JavaScript може динамично да преминава от dense към sparse и обратно, в зависимост от начина, по който добавяме или премахваме елементи. JavaScript автоматично променя вътрешната структура на масива според нуждите на програмата.

Ако имаме само един елемент сложен на определен елемент, примерно 100, то дължината на масива ще бъде 101:

```javascript
   let arr = [];
    arr[100] = 1;
    console.log(arr.length); //101
```

Този масив, заема само една клетка в паметта.
### Element Access
Може да достъпваме елементите по индекс:

```javascript
    let arr = [1, 2, 3, 4];

    // Access elements (by index)
    console.log(arr[0]); // get first element
    console.log(arr[arr.length - 1]); // get last element

    // Access non existent element
    console.log(arr[30]); //undefined
```

Ако се опитаме да достъпим индекс на несъществуващ елемент или отрицателен индекс `[-1]`, няма да получим грешка, но върнатата стойност ще е `undefined`.
### Destructuring Assignment
Израз чрез който разопаковаме стойности от масив или обекти в отделни променливи.

```javascript
    let arr = [1, 2, 3];
    let [firstNumber, secondNumber, thirdNumber] = arr; //firstNumber = 1...
```

Създаваме няколко променливи на база позицията на елементите вътре в масива. Може да се ползват като обикновени променливи. Масива си остава без промяна. Това е съкратен начин да даваме стойност на няколко променливи, без да се налага да ги декларираме отделно. Типа на променливите, зависи от типа на елементите в масива.

Може да имаме и patricidal destructuring, където взимаме само някаква част от елементите на масива. Ако използваме `rest` оператора - `...` това ще вземе останалите елементи и ще ги запише в масив.

```javascript
    let arr = [1, 2, 3];
    let [firstNumber, ...restNames] = arr;
    
    console.log(firstNumber); // 1
    console.log(restNames); // (2) [2, 3]
```

Ако искаме да вземем втория и третия елемент, може да изредим със запетайка, елементите които искаме да пропуснем:

```javascript
function solve(numbers) {
    let [, secondNumber, , lastNumber] = numbers;
}

solve([1, 2, 3, 4]);
```

`secondNumber` ще е равно на 2 а `lastNumber` ще е равно на 4. Не се препоръчва, защото прави кода по-труден за четене, трябва се изброи със запетайка. Обикновено се използва долната черта `_` за обозначаване на променливи, които няма да използваме, особено ако пропускаме само един елемент - `let [_, secondNumber] = [1, 2, 3, 4];`
### `...` Operator
Операторът `...` (известен като "spread" или "rest" оператор) има различни приложения в зависимост от контекста, в който се използва.
Когато се използва оператора `...` от лявата страна на присвояване (като при деструктуриране на масив или обект), той събира останалите елементи в нова променлива. Това се нарича **rest оператор**, защото „събира остатъка“ от елементите.

От друга страна, **spread операторът** се използва при разширяване или „разгръщане“ на елементи, като при комбиниране на масиви или подаване на елементи на масив като аргументи на функция.

Тук `...numbers` позволява на функцията да приема произволен брой аргументи и да ги събере в масив. Подобен е на `params` в C# и също трябва да бъде последен параметър.

```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

Има и трети вариант - "spread syntax" където се използва за разширяване на елементи в масиви, обекти или при извикване на функции:

1. **В масиви**: Добавя елементи на един масив към друг:
    
```javascript
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]
```
    
2. **В извикване на функции**: Подсигурява елементите на масив като аргументи за функция:
    
```javascript
function sum(a, b, c) {
    return a + b + c;
}

let numbers = [1, 2, 3];
sum(...numbers); // Резултат: 6
```
    
3. **В обекти**: Копира или комбинира свойства на обекти:
    
```javascript
let obj1 = { x: 1, y: 2 };
let obj2 = { ...obj1, z: 3 }; // { x: 1, y: 2, z: 3 }
```
### For-of Loop
```javascript
    let numbers = [1, 2, 3, 4];

    for (let number of numbers) {
        console.log(number);
    }
```

Еквивалент на `foreach` в C#, итерира през всички елементи в масива и за всяка итерация присвоява стойността на текущия елемент на декларираната с led променлива.
### Methods
Списък с методи и какво правят има в папката с ресурси във файла за JavaScript.
Имаме два типа метода, които може да използваме върху масивите - **мутиращи** и **не-мутиращи**.

**Mutating**
Работят директно върху оригиналния масив и го променят.
Не мутиращите, ще копират оригиналния масив в нов масив, без да променят оригиналния.

**Non-Mutating**
Създават и връщат нов масив, без да променят оригиналния. Така оригиналният масив остава непокътнат.

**Iterative Methods**
Тези методи са предимно non-mutating и позволяват извършването на операции върху масиви по начин, който наподобява LINQ в C#.

Приемат:
- **Callback Function**: Подобно на делегатите в C#, тези методи очакват функция като аргумент. Всички функции, които се подават като аргументи на методи в JavaScript, се наричат callback функции. Те могат да бъдат от различен тип, в зависимост от контекста, в който се използват.
- **Predicate Function**: Някои от методите, като `filter()`, приемат специален вид callback функция наречена predicate, която определя условията, по които елементите от масива ще бъдат включени в новия масив. Тази функция връща true или false, в зависимост дали елемента отговаря на условията.
- **Other Arguments**: Много от тези методи приемат и допълнителни аргументи, като `thisArg`, който задава контекста за `this` в callback функцията.
- **Index и Целия Масив**: Итеративните методи предоставят на callback функциите не само текущия елемент, но и неговия индекс и целия масив. Това позволява извършването на операции, които зависят от позицията на елемента или от самия масив.

Callback функциите, предлагат гъвкавост и могат да бъдат представени по различни начини, което улеснява работата с методи като `filter`, `map`, и `reduce`. Това прави кода по-интуитивен и по-лесен за четене! Те могат да бъдат подавани като именувана функция, анонимна функция (function expression) или стрелкова функция (arrow function).

**Примери:**

```javascript    
// Named function
    function printElement(element) {
        console.log(element);
    }

    arr.forEach(printElement);

    // Function Expression
    arr.forEach(function (element) {
        console.log(element);
    });

    // Arrow Function
    arr.forEach((element) => {
        console.log(element);
    });
```

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS.
## Manipulating Strings
При стринговете, всички методи са non-mutating - създават и връщат нов стринг на базата на стария.
### Literals
Стринговите литерали с една и двойни кавички са еднакви - 'text', "text". 

Имаме и template литерал - (` `` `) и се използва за интерполация на променливи и изрази, работи по-бавно защото търси променлива. Също така позволява много редови стрингове. 
### Escaping
Ако искаме да напишем двойни кавички в string-a, може да ползваме единични - `'"Quote"'`
Може и обратното - `"'Quote'"`.
Може да се ползва и backslash - `\`  който служи да премахне специалното значение на символа. - `'\'Quote\''`
### Concatenation
Събиране на два стринга с `+` оператора.
Може да се ползва метода `firstString.concat(secondString)`
### Methods
Списък с методи и какво правят има в папката с ресурси във файла за JavaScript.
## RegExp in JS
Регулярните изрази (RegExp) са подход за търсене и манипулиране на текстове по зададени шаблони. Те са изключително полезен инструмент за валидация на данни, търсене на конкретни символни последователности и извършване на замени в текст. 
Въпреки че има разлики между синтаксиса на regex в различни езици, практическите различия са минимални и основните концепции остават еднакви.
Разликата е в начина по който се интегрира и използва в съответните езици.
### Creating RegExp
Има два основни начина за създаване на регулярни изрази в JavaScript:
#### Literals
Регулярният израз се записва между две наклонени черти (`/`). Вътре в тях пишем шаблона, който искаме да търсим.

```javascript
let pattern = /[A-Z][a-z]+/g; // Seaching for a word starting with a capital letter followed by one or more smaller letters with global flag
```

Това е начина за предпочитане, защото е по-лесен за писане, но с по-малко възможности.
#### RegExp class
Регулярните изрази могат да бъдат създадени и чрез конструктора `RegExp`. Този метод е полезен, когато шаблонът е динамичен и не може да бъде зададен статично. Може да се сложат променливи вътре в самия pattern.

```javascript
let pattern = new RegExp('[A-Z][a-z]+', 'g'); // Същото търсене, но с конструктор
```
### Methods
Списък с методи и какво правят има в папката с ресурси във файла за JavaScript.
[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Методите се делят на два вида:

**RegExp:**
Използват се върху самия тип на regex.

**String:**
Стрингови методи, които използват regex вътре в аргументите си.
# Misc
## JS Front-End
Този курс покрива малка част от JS Fundamentals, голяма част от JS Advanced  и средна / малка част от JS Applications - три курса сбити в едно.
# ChatGPT
## Function Default Return Value
in JavaScript, if a function does not explicitly return a value using the `return` statement, it will return `undefined` by default. This behavior is consistent across all functions, including named functions, function expressions, and arrow functions.
## Autocomplete Suggestions with Default Parameter Values
By specifying the type in the parameter, editors like VS Code can often infer the expected methods that apply to that type. For example, if you want to work with `stringParameter` as a string, you can initialize it as an empty string (`''`). This tells the editor that `myString` is a string, so you’ll see string-related methods and properties suggested within the `solve` function.

Here’s how it works:

```javascript
solve(myString = '') {
    // Now `myString` is inferred as a string, so typing `myString.` will show all string methods
}
```

This approach can be applied to other types too, by setting the parameter to a default value of that type. Here are a few examples:

1. **For Arrays:**

```javascript
solve(numbers = []) { // `numbers` is inferred as an array, so you'll see array methods. }
```

2. **For Objects:**

```javascript
solve(config = {}) {
    // `config` is inferred as an object, so you’ll get object-related methods.
}
```

3. **For Numbers:**

```javascript
solve(count = 0) {
    // `count` is inferred as a number, so you’ll see number-related methods.
}
```

This technique is a helpful way to ensure autocompletion and method suggestions align with the intended type of the parameter in your function.
# Bookmarks
https://developer.mozilla.org/en-US/ - the official JS documentation.

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS.

[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Completion: 31.10.2024