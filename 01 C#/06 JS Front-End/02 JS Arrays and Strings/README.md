# General
## Arrays
Списъчен тип обекти - еднотипни данни комбинирани заедно. Признака по който комбинираме неща заедно е техния тип.

Те са референтен тип - тяхната променлива сочи към адрес в паметта, където стои този масив.
Паметта е разделена на stack и heap. Stack-a е заделена памет, специално за execution-a нашата програма, лимитиран от няколко мегабайта. В него държим execution context-ите на всички функции, променливите, параметрите, call stack-a с извиканите функции, всички примитивни типове се записват директно в там. Stack паметта е ограничена по размер и обикновено по-бърза, защото е силно организирана и управлявана от компютъра чрез LIFO (last in, first out) подход. 
Когато имаме променлива, която държи примерно масив, в stack-a имаме само референция / адреса, сочещи към heap-a - мястото в паметта, където се намира масива. Heap-a е оперативната памет, която имаме на машината и от нея се заделя място за референтните данни, в нашата програма. Динамични данни като референтни типове данни (например масиви, обекти и други структури, чиито размер може да се променя). Управлението на heap паметта изисква повече време и е по-гъвкаво, тъй като позволява динамично разпределение и освобождаване на памет, когато вече не е нужна. Това е по подобие на pointers в C++ и C. Разликата между референция и pointer е, че pointer-a е действителна променлива, която съдържа адрес в паметта, и можем директно да достъпваме стойността му като число. Можем също така да променяме стойността му, за да посочва към различни адреси, което дава много контрол, но също така изисква повече внимание за избягване на грешки. С pointer-ите може да правим операции, pointer-a си е сам по себе си тип, като например`int*`, `float*` и т.н., докато в JavaScript и C# референциите не се възприемат като отделен тип. Референцията просто сочи към обект в `heap` паметта. Така че, макар да споделят идеята за указване към паметта, `pointers` и референциите са различни в своето предназначение, безопасност и контрол.

Всеки масив си има клетка с индекс започващи от 0, масив от 5 елемента ще има индекси започващи от 0 до 4. Последния индекс на елемента се намира като извадим от общия брой на елементите 1.

Литерала за масив са квадратните скоби `[]`.

Масива в JS прилича повече на List-a в C#, няма нужда да посочваме неговата дължина предварително. Може да си декларираме празен масив и неговата дължина се променя динамично.

Дължината и типа не са фиксирани, може да имаме масив с различни типове данни вътре. Не е добра практика да се смесват типовете данни и трябва да се избягва.

Ако изпишем на конзолата масива, ще покаже стойността на елементите и техния брой.

Може да променим броя на елементите в масива като зададем стойност на `length`. Така ако посочим по-голяма дължина от броя на елементите му, ще добавим празни елементи. Ако посочим по-малка дължина, ще изтрием елементите излизащи от нея.

```javascript
    let array = [];
    array.length = 10;
```

Данните може да бъдат съхранявани в non-conttiguous locations (последователни съседни клетки) в паметта. Примерно първите елементи може да се намират в две клетки, следващите в други клетки на друго място в паметта и тн. С други думи, масива може да бъде разпръснат в различни клети в паметта. Реално за нас е важно като извикаме масива, да го получим, няма значение къде се намира в паметта.
### Dense / Sparse Arrays
Масивите биват dense (плътен) и sparse (разреден). Това са двата вида масива, които може да има в езиците.

```javascript
    let denseArr = [undefined, undefined, undefined];
    let sparseArr = [];
    sparseArr.length = 3;

    console.log(denseArr.length === sparseArr.length);   // true
    console.log(denseArr); // (3) [undefined, undefined, undefined]
    console.log(sparseArr); //(3) […]
```

И двата масива имат три празни елемента, само че dense масива съдържа три последователни стойности, докато sparse масива е празен. `undefined` се явяват реални стойности, които си заемат място, докато при sparse елементите не съществуват на ниво памет. Не всеки език има такова свойство, примерно може да декларираме масив от много елементи, който няма да заема място в паметта. В C# когато декларираме масив, то масива си има строго определен размер, базиращ се на типа данни и броя елементи, което означава че са dense масиви. В JS имаме свойството на sparse масивите, примерно може да имаме първите няколко елемента да са реални а след това да имам дупка от няколко хиляди елемента. 

При обхождане с `for` цикъл или при директен достъп като `sparseArr[i]`, JavaScript ще покаже `undefined` за „празните“ индекси, дори ако те реално не заемат място в паметта.
Това се дължи на начина, по който JavaScript работи със sparse масиви. Някои индекси може да не са заделени, но когато се опитаме да достъпим неинициализиран индекс, JavaScript връща `undefined` като стойност по подразбиране. Този `undefined` обаче не съществува физически в паметта – той е по-скоро логическа стойност, показваща, че няма дефиниран елемент на този индекс.

JavaScript двигателят първоначално ще съхранява масива като dense, ако е възможно. Ако обаче започнем да добавяме елементи на произволни индекси, оставяйки много празни места, масивът може да бъде преобразуван в sparse, което е по-малко оптимизирано за памет и производителност. 
Всеки масив в JavaScript може динамично да преминава от dense към sparse и обратно, в зависимост от начина, по който добавяме или премахваме елементи. JavaScript автоматично променя вътрешната структура на масива според нуждите на програмата.

Ако имаме само един елемент сложен на определен елемент, примерно 100, то дължината на масива ще бъде 101:

```javascript
   let arr = [];
    arr[100] = 1;
    console.log(arr.length); //101
```

Този масив, заема само една клетка в паметта.
### Element Access
Може да достъпваме елементите по индекс:

```javascript
    let arr = [1, 2, 3, 4];

    // Access elements (by index)
    console.log(arr[0]); // get first element
    console.log(arr[arr.length - 1]); // get last element

    // Access non existent element
    console.log(arr[30]); //undefined
```

Ако се опитаме да достъпим индекс на несъществуващ елемент или отрицателен индекс `[-1]`, няма да получим грешка, но върнатата стойност ще е `undefined`.
### Destructuring Assignment
Израз чрез който разопаковаме стойности от масив или обекти в отделни променливи.

```javascript
    let arr = [1, 2, 3];
    let [firstNumber, secondNumber, thirdNumber] = arr; //firstNumber = 1...
```

Създаваме няколко променливи на база позицията на елементите вътре в масива. Може да се ползват като обикновени променливи. Масива си остава без промяна. Това е съкратен начин да даваме стойност на няколко променливи, без да се налага да ги декларираме отделно. Типа на променливите, зависи от типа на елементите в масива.

Може да имаме и patricidal destructuring, където взимаме само някаква част от елементите на масива. Ако използваме `rest` оператора - `...` това ще вземе останалите елементи и ще ги запише в масив.

```javascript
    let arr = [1, 2, 3];
    let [firstNumber, ...restNames] = arr;
    
    console.log(firstNumber); // 1
    console.log(restNames); // (2) [2, 3]
```

Ако искаме да вземем втория и третия елемент, може да изредим със запетайка, елементите които искаме да пропуснем:

```javascript
function solve(numbers) {
    let [, secondNumber, , lastNumber] = numbers;
}

solve([1, 2, 3, 4]);
```

`secondNumber` ще е равно на 2 а `lastNumber` ще е равно на 4. Не се препоръчва, защото прави кода по-труден за четене, трябва се изброи със запетайка. Обикновено се използва долната черта `_` за обозначаване на променливи, които няма да използваме, особено ако пропускаме само един елемент - `let [_, secondNumber] = [1, 2, 3, 4];`
### `...` Operator
Операторът `...` (известен като "spread" или "rest" оператор) има различни приложения в зависимост от контекста, в който се използва.
Когато се използва оператора `...` от лявата страна на присвояване (като при деструктуриране на масив или обект), той събира останалите елементи в нова променлива. Това се нарича **rest оператор**, защото „събира остатъка“ от елементите.

От друга страна, **spread операторът** се използва при разширяване или „разгръщане“ на елементи, като при комбиниране на масиви или подаване на елементи на масив като аргументи на функция.

Тук `...numbers` позволява на функцията да приема произволен брой аргументи и да ги събере в масив. Подобен е на `params` в C# и също трябва да бъде последен параметър.

```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

Има и трети вариант - "spread syntax" където се използва за разширяване на елементи в масиви, обекти или при извикване на функции:

1. **В масиви**: Добавя елементи на един масив към друг:
    
```javascript
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]
```
    
2. **В извикване на функции**: Подсигурява елементите на масив като аргументи за функция:
    
```javascript
function sum(a, b, c) {
    return a + b + c;
}

let numbers = [1, 2, 3];
sum(...numbers); // Резултат: 6
```
    
3. **В обекти**: Копира или комбинира свойства на обекти:
    
```javascript
let obj1 = { x: 1, y: 2 };
let obj2 = { ...obj1, z: 3 }; // { x: 1, y: 2, z: 3 }
```
### For-of Loop
```javascript
    let numbers = [1, 2, 3, 4];

    for (let number of numbers) {
        console.log(number);
    }
```

Еквивалент на `foreach` в C#, итерира през всички елементи в масива и за всяка итерация присвоява стойността на текущия елемент на декларираната с led променлива.
### Methods
Имаме два типа метода, които може да използваме върху масивите - **мутиращи** и **не-мутиращи**.
### Mutating 
Работят директно върху оригиналния масив и го променят.
Не мутиращите, ще копират оригиналния масив в нов масив, без да променят оригиналния.

`pop()` - маха последния елемент от масива и го връща като стойност.

`push(value)` - вкарва елемент в края на масива и връща новата дължина на масива. Може да се добавят повече от един елементи.  Може да се ползва в комбинация с `...` за да добави елементите на даден масив:

```javascript
    let arr = [1, 2, 3, 4];
    let arr2 = [6, 7, 8];

    arr.push(5, ...arr2, 9); // 1, 2, 3, 4, 5, 6, 7, 8, 9
```

`shift()` - маха първия елемент, ще го върне като стойност и ще пренареди целия масив - всички елементи ще се преместят с един индекс назад.

`unshift(value)` - добавя елемент / елементи в началото на масива, което ще пренареди индексите на останалите елементи и връща новата дължина на масива.

`splice(start, deleteCount)` - махаме count елементи стартиращи от посочения индекс. Ако няма посочен count, изтрива всичко след посочения индекс. Ако индексът е отрицателен, той се брои от края на масива, примерно -1 ще е последния елемент, -2 предпоследния и така. Ако индекса излиза от рамките на масива, ще спре на последния съществуващ елемент. Връща масив с изтритите елементи, дори да е само един елемент пак ще върне масив. Ако има нужда, останалите елементи се пренареждат.

`splice(start, deleteCount, elementsToAdd)` - След като изтрие посочените елементи, добавя нов елемент / елементи на тяхно място. Ако сложим 0 на count, тогава ще insert-не елементите на този индекс, без да изтрива нищо. 

`reverse()` - пренарежда целия масив наобратно и връща като референция същия масив.
### Non-Mutating
Създават и връщат нов масив, без да променят оригиналния. Така оригиналният масив остава непокътнат.

`join(separator)` - обединява всички елементи в даден масив и ги връща като string разделени от посочения сепаратор. Ако няма посочен сепаратор, ще по подразбиране ще е `,`.

`slice(start, end)` - взима subarray / парче от масива, като започва от  `startIndex` и взима до `lastIndex`, но не включително - `lastIndex` не се включва в резултата. Връща нов масив, който съдържа изрязаните елементи. Когато нямаме зададен `lastIndex` взима всичко до края. Може да се ползват и отрицателни индекси.

`slice()` - ще направи shallow копие на целия масив. Новият масив ще съдържа същите елементи като оригиналния, но ще бъде независим от него. ако масивът съдържа обекти или вложени масиви, `slice()` копира само референциите към тях, а не самите обекти. Това е причината да се нарича shallow копие, а не deep копие.

`includes(searchElement, fromIndex)` - проверява дали дадена стойност я има в масива, връща boolean. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`indexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на първия срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`lastIndexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на последния срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.
### Iterative Methods
Тези методи са non-mutating и позволяват извършването на операции върху масиви по начин, който наподобява LINQ в C#.
Приемат:
- **Callback Function**: Подобно на делегатите в C#, тези методи очакват функция като аргумент. Тази функция може да бъде подадена като именувана функция, анонимна функция (function expression) или стрелкова функция (arrow function).
- **Predicate Function**: Някои от методите, като `filter()`, приемат predicate функции, които определят условията, по които елементите от масива ще бъдат включени в новия масив. Тази функция връща true или false, в зависимост дали елемента отговаря на условията.
- **Other Arguments**: Много от тези методи приемат и допълнителни аргументи, като `thisArg`, който задава контекста за `this` в callback функцията.

**Примери:**

```javascript    
// Named function
    function printElement(element) {
        console.log(element);
    }

    arr.forEach(printElement);

    // Function Expression
    arr.forEach(function (element) {
        console.log(element);
    });

    // Arrow Function
    arr.forEach((element) => {
        console.log(element);
    });
```

`forEach(callback)` - изпълнява подадената функция за всеки един от елементите в масива (колекцията).

`map(callback)` - трансформира всеки един от елементите в масива, подобен е на `Select()` в C#.

`find(predicate)` - връща първия елемент, който отговаря на даден филтър.

`filter(predicate)` - връща масив с всички елементи, отговарящи на даден филтър.

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS
## Manipulating Strings
При стринговете, всички методи са non-mutating - създават и връщат нов стринг на базата на стария.
### Literals
Стринговите литерали с една и двойни кавички са еднакви - 'text', "text". 

Имаме и template литерал - (` `` `) и се използва за интерполация на променливи и изрази, работи по-бавно защото търси променлива. Също така позволява много редови стрингове. 
### Escaping
Ако искаме да напишем двойни кавички в string-a, може да ползваме единични - `'"Quote"'`
Може и обратното - `"'Quote'"`.
Може да се ползва и backslash - `\`  който служи да премахне специалното значение на символа. - `'\'Quote\''`
### Concatenation
Събиране на два стринга с `+` оператора.
Може да се ползва метода `firstString.concat(secondString)`
### Methods
`indexOf(searchString, position)` - намира началния индекс на първия текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`lastIndexOf(searchString, position)` - намира началния индекс на последния текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`substring(start, end)` - взима substring-а започващ от индекса start и стигащ до end без да го включва. Ако не се подаде end ще вземе всичко до края.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`). `searchValue` може да бъде стринг или регулярeн израз (regex). 

`replaceAll(searchValue, replaceValue)` - замества всички срещнати стрингове (`searchValue`) с ново съдържание (`replaceValue`). `searchValue` може да бъде стринг или регулярeн израз (regex). 

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```

Ако искаме да разделим текст само по интервали и да избегнем празните елементи, които се получават, когато имаме повече от един интервал един след друг, може да използваме `/[ ]+/` в `split`. Това гарантира, че дори и да има няколко поредни интервала, те ще бъдат разглеждани като един разделител.

`includes(searchString, position)` - проверява дали дадена стойност я има в стринга, връща boolean. Ако сложим `position` ще започне да търси от дадения индекс.

`'stringToRepeat'.repeat(count)` - повтаря `stringToRepeat` `count` на брой пъти.

`trimStart()` - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от началото на стринга.

`trimEnd() `  - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от края.

`trim()` - изтрива whitespaces (интервал, нов ред или tab) от началото и края.

`startsWith(searchString, position)` - проверява дали даден стринг започва с `searchString` и връща boolean. По избор може да се посочи и `position`, от където да започне търсенето (по подразбиране е 0). Има значение дали буквите са главни или малки.

`endsWith(searchString, position)` - проверява дали даден стринг завършва с `searchString` и връща boolean. По избор може да се посочи и `position`, от кой краен индекс да завършва търсенето (по подразбиране е дължината на стринга). Има значение дали буквите са главни или малки.

`padStart(maxLength, fillString)` - добавя padding (допълнителни символи) в началото на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.

`padEnd(maxLength, fillString)` - добавя padding (допълнителни символи) в края на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.
## RegExp in JS
Регулярните изрази (RegExp) са подход за търсене и манипулиране на текстове по зададени шаблони. Те са изключително полезен инструмент за валидация на данни, търсене на конкретни символни последователности и извършване на замени в текст. 
Въпреки че има разлики между синтаксиса на regex в различни езици, практическите различия са минимални и основните концепции остават еднакви.
Разликата е в начина по който се интегрира и използва в съответните езици.
### Creating RegExp
Има два основни начина за създаване на регулярни изрази в JavaScript:
#### Literals
Регулярният израз се записва между две наклонени черти (`/`). Вътре в тях пишем шаблона, който искаме да търсим.

```javascript
let pattern = /[A-Z][a-z]+/g; // Seaching for a word starting with a capital letter followed by one or more smaller letters with global flag
```

Това е начина за предпочитане, защото е по-лесен за писане, но с по-малко възможности.
#### RegExp class
Регулярните изрази могат да бъдат създадени и чрез конструктора `RegExp`. Този метод е полезен, когато шаблонът е динамичен и не може да бъде зададен статично. Може да се сложат променливи вътре в самия pattern.

```javascript
let pattern = new RegExp('[A-Z][a-z]+', 'g'); // Същото търсене, но с конструктор
```
### Methods
[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Методите се делят на два вида:
### RegExp
Използват се върху самия тип на regex.

`pattern.test(string)` - тества дали патърна, ще върне резултат в търсения текст и връща boolean.

`pattern.exec(string)` - този метод връща масив където първия елемент е самото съвпадение. Останалите елементи (ако има) са резултати от групирането в регулярния израз (ако имаме групи). Ако не намери съвпадение, връща `null`. Ако има повече от едно съвпадение на регулярния израз, ще намери само първото съвпадение. 
За да намерим всички съвпадения, можем да ползваме глобалния флаг `g` -`exec()` ще запомни последната позиция на търсене и при всяко следващо извикване ще продължи оттам. Друг вариант е да се ползва стринговия метод `match()`.
### String
Стрингови методи, които използват regex вътре в аргументите си.

`match(pattern)` - връща първия резултат, който намира, на кой индекс, групата ако има такава и input text-a в който е търсил. Ако искаме да върне всички резултати, трябва да добавим глобалния флаг `g` в pattern-на. Така ще върне всички резултати, но няма да покаже никаква допълнителна информация, като индекса и input text-a.

`matchAll(pattern)` - намира всички резултати и ги добавя в `RegExpStringIterator`. Трябва да го добавим в един `for-of loop` и така може да ги видим поотделно. Трябва да има добавен глобалния флаг `g` в pattern-на.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`). `searchValue` може да бъде стринг или регулярeн израз (regex). Ако искаме да замести всички резултати отговарящи на pattern-на, трябва да има глобалния флаг `g`.

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Особено полезно е да се ползва regex, когато имаме различни сепаратори. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```
# Misc
## JS Front-End
Този курс покрива малка част от JS Fundamentals, голяма част от JS Advanced  и средна / малка част от JS Applications - три курса сбити в едно.
# ChatGPT
## Function Default Return Value
in JavaScript, if a function does not explicitly return a value using the `return` statement, it will return `undefined` by default. This behavior is consistent across all functions, including named functions, function expressions, and arrow functions.
## Autocomplete Suggestions with Default Parameter Values
By specifying the type in the parameter, editors like VS Code can often infer the expected methods that apply to that type. For example, if you want to work with `stringParameter` as a string, you can initialize it as an empty string (`''`). This tells the editor that `myString` is a string, so you’ll see string-related methods and properties suggested within the `solve` function.

Here’s how it works:

```javascript
solve(myString = '') {
    // Now `myString` is inferred as a string, so typing `myString.` will show all string methods
}
```

This approach can be applied to other types too, by setting the parameter to a default value of that type. Here are a few examples:

1. **For Arrays:**

```javascript
solve(numbers = []) { // `numbers` is inferred as an array, so you'll see array methods. }
```

2. **For Objects:**

```javascript
solve(config = {}) {
    // `config` is inferred as an object, so you’ll get object-related methods.
}
```

3. **For Numbers:**

```javascript
solve(count = 0) {
    // `count` is inferred as a number, so you’ll see number-related methods.
}
```

This technique is a helpful way to ensure autocompletion and method suggestions align with the intended type of the parameter in your function.
# Bookmarks
https://developer.mozilla.org/en-US/ - the official JS documentation.

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS.

[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Completion: 31.10.2024