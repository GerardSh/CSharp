# General
## What is an Array
Списъчен тип обекти - еднотипни данни комбинирани заедно. Признака по който комбинираме неща заедно е техния тип.

Те са референтен тип - тяхната променлива сочи към адрес в паметта, където стои този масив.
Паметта е разделена на stack и heap. Stack-a е заделена памет, специално за execution-a нашата програма, лимитиран от няколко мегабайта. В него държим execution context-ите на всички функции, променливите, параметрите, call stack-a с извиканите функции, всички примитивни типове се записват директно в там. Stack паметта е ограничена по размер и обикновено по-бърза, защото е силно организирана и управлявана от компютъра чрез LIFO (last in, first out) подход. 
Когато имаме променлива, която държи примерно масив, в stack-a имаме само референция / адреса, сочещи към heap-a - мястото в паметта, където се намира масива. Heap-a е оперативната памет, която имаме на машината и от нея се заделя място за референтните данни, в нашата програма. Динамични данни като референтни типове данни (например масиви, обекти и други структури, чиито размер може да се променя). Управлението на heap паметта изисква повече време и е по-гъвкаво, тъй като позволява динамично разпределение и освобождаване на памет, когато вече не е нужна. Това е по подобие на pointers в C++ и C. Разликата между референция и pointer е, че pointer-a е действителна променлива, която съдържа адрес в паметта, и можем директно да достъпваме стойността му като число. Можем също така да променяме стойността му, за да посочва към различни адреси, което дава много контрол, но също така изисква повече внимание за избягване на грешки. С pointer-ите може да правим операции, pointer-a си е сам по себе си тип, като например`int*`, `float*` и т.н., докато в JavaScript и C# референциите не се възприемат като отделен тип. Референцията просто сочи към обект в `heap` паметта. Така че, макар да споделят идеята за указване към паметта, `pointers` и референциите са различни в своето предназначение, безопасност и контрол.

Всеки масив си има клетка с индекс започващи от 0, масив от 5 елемента ще има индекси започващи от 0 до 4. Последния индекс на елемента се намира като извадим от общия брой на елементите 1.

Литерала за масив са квадратните скоби `[]`.

Масива в JS прилича повече на List-a в C#, няма нужда да посочваме неговата дължина предварително. Може да си декларираме празен масив и неговата дължина се променя динамично.

Дължината и типа не са фиксирани, може да имаме масив с различни типове данни вътре. Не е добра практика да се смесват типовете данни и трябва да се избягва.

Ако изпишем на конзолата масива, ще покаже стойността на елементите и техния брой.

Може да променим броя на елементите в масива като зададем стойност на `length`. Така ако посочим по-голяма дължина от броя на елементите му, ще добавим празни елементи. Ако посочим по-малка дължина, ще изтрием елементите излизащи от нея.

```javascript
    let array = [];
    array.length = 10;
```

Данните може да бъдат съхранявани в non-conttiguous locations (последователни съседни клетки) в паметта. Примерно първите елементи може да се намират в две клетки, следващите в други клетки на друго място в паметта и тн. С други думи, масива може да бъде разпръснат в различни клети в паметта. Реално за нас е важно като извикаме масива, да го получим, няма значение къде се намира в паметта.
### Dense / Sparse Arrays
Масивите биват dense (плътен) и sparse (разреден). Това са двата вида масива, които може да има в езиците.

```javascript
    let denseArr = [undefined, undefined, undefined];
    let sparseArr = [];
    sparseArr.length = 3;

    console.log(denseArr.length === sparseArr.length);   // true
    console.log(denseArr); // (3) [undefined, undefined, undefined]
    console.log(sparseArr); //(3) […]
```

И двата масива имат три празни елемента, само че dense масива съдържа три последователни стойности, докато sparse масива е празен. `undefined` се явяват реални стойности, които си заемат място, докато при sparse елементите не съществуват на ниво памет. Не всеки език има такова свойство, примерно може да декларираме масив от много елементи, който няма да заема място в паметта. В C# когато декларираме масив, то масива си има строго определен размер, базиращ се на типа данни и броя елементи, което означава че са dense масиви. В JS имаме свойството на sparse масивите, примерно може да имаме първите няколко елемента да са реални а след това да имам дупка от няколко хиляди елемента. 

При обхождане с `for` цикъл или при директен достъп като `sparseArr[i]`, JavaScript ще покаже `undefined` за „празните“ индекси, дори ако те реално не заемат място в паметта.
Това се дължи на начина, по който JavaScript работи със sparse масиви. Някои индекси може да не са заделени, но когато се опитаме да достъпим неинициализиран индекс, JavaScript връща `undefined` като стойност по подразбиране. Този `undefined` обаче не съществува физически в паметта – той е по-скоро логическа стойност, показваща, че няма дефиниран елемент на този индекс.

JavaScript двигателят първоначално ще съхранява масива като dense, ако е възможно. Ако обаче започнем да добавяме елементи на произволни индекси, оставяйки много празни места, масивът може да бъде преобразуван в sparse, което е по-малко оптимизирано за памет и производителност. 
Всеки масив в JavaScript може динамично да преминава от dense към sparse и обратно, в зависимост от начина, по който добавяме или премахваме елементи. JavaScript автоматично променя вътрешната структура на масива според нуждите на програмата.

Ако имаме само един елемент сложен на определен елемент, примерно 100, то дължината на масива ще бъде 101:

```javascript
   let arr = [];
    arr[100] = 1;
    console.log(arr.length); //101
```

Този масив, заема само една клетка в паметта.
## Element Access
Може да достъпваме елементите по индекс:

```javascript
    let arr = [1, 2, 3, 4];

    // Access elements (by index)
    console.log(arr[0]); // get first element
    console.log(arr[arr.length - 1]); // get last element

    // Access non existent element
    console.log(arr[30]); //undefined
```

Ако се опитаме да достъпим индекс на несъществуващ елемент или отрицателен индекс `[-1]`, няма да получим грешка, но върнатата стойност ще е `undefined`.
# Misc

# ChatGPT

# Bookmarks
https://developer.mozilla.org/en-US/ - the official JS documentation