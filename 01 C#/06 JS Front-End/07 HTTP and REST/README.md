# General
## HTTP
### HTTP (Hypertext Transfer Protocol) Overview
Протокол за комуникация - списък от инструкции за комуникация между две страни.

Interconnected network представлява концепцията за обединяване на множество локални и глобални мрежи чрез различни технологии за комуникация. Интернет е най-голямата и известна такава мрежа, която свързва милиарди устройства по света.

Услугата в интернет е www - World Wide Web, която ползваме за да имаме достъп до web ресурсите. Посредством тази услуга, получаваме ресурси.

Web стандартно има две страни на комуникацията - клиент и сървър. Клиента е инициатора на комуникацията , този който прави запитване а сървъра е, който отговаря на запитването. Това е request - response модел. Посоката е винаги от клиента към сървъра. За да може да се извърши комуникацията, двете страни използват HTTP.

HTTP е текстово базиран протокол за правене на заявки и връщане на отговор между клиент и сървър. Това е универсален протокол в web.

Чрез този протокол трансферираме Web ресурси като HTML / JS файлове, снимки, стилове и тн.

Най-често заявките са за достъпване на Web ресурс, като ако заявката е правилна и сървъра го има, ще го върне към клиента и ще бъде зареден в браузъра.

Клиента е софтуер, който може да инициира HTTP Web комуникация, като обикновено това е браузър, но може да бъде и десктоп програма, игра и тн.

Сървъра също е софтуер, който може да бъде инсталиран на произволен хардуер. Работи като process / service / daemon, което е безкрайна програма, която работи, докато не бъде спряна и слуша за HTTP requests. Сървъра слуша на определен порт и има готовност да посрещне и отговори на тези заявки. Портовете са нужни, за да може комуникацията с външния свят на една машина да се разпознава от кого и за кого е. Това е нещо като пристанище където имаме различни докове за приемане и изпращане на различни товарни кораби, които знаят на кой док точно да разтоварят или натоварят. Всяка програма или услуга използва определен порт, чрез който осъществява комуникацията си. Някои приложения използват стандартни портове, за да бъдат разпознати (като HTTP през порт 80), докато други използват динамични портове, които се задават временно за конкретна сесия.
Сървърните програми са различни и се използват според технологията, за която са оптимизирани. Например, Apache е популярен в света на PHP, Nginx често се предпочита за Python приложения и като обратен прокси, IIS (Internet Information Services) е основният избор за .NET среди, а Tomcat се използва широко за Java приложения. Освен тях има и други специализирани сървъри според конкретните нужди. За JavaScript съществуват вградени самостоятелни сървъри (self-hosted), като например тези, които идват с Node.js, което позволява създаване на приложения без нужда от външен уеб сървър. Подобно, в .NET средата има вградени хостинг възможности, като Kestrel – самостоятелен уеб сървър, който е част от ASP.NET Core.
### HTTP Request Methods
![](Pasted%20image%2020241201134020.png)
Методите са начини, по които оказваме допълнителна информация какво всъщност искаме да направим с дадена заявка. Целта е сървъра да разбере, какво е действието, което искаме да извършим със заявката.
#### CRUD - Create Read Update Delete
CRUD операциите са концепция за манипулация на данни, HTTP методите са инструмент за комуникация между клиент и сървър. HTTP методите са конкретен механизъм за осъществяване на тези действия чрез заявки между клиент и сървър. Те не са ограничени до CRUD, но често се използват за неговото изпълнение:

POST за Create.
GET за Read.
PUT и PATCH за Update.
DELETE за Delete.
#### GET
Това е метода по default, който взима ресурси.
#### POST
Заявка че искаме да създадем ресурс на сървъра, който да се запази. Примерно, ако напишем коментар във форум, това е създаване на ресурс.
#### PUT
Заявка за промяна на вече създаден ресурс. Примерно, ако искаме да променим вече създаден коментар.
#### DELETE
Заявка за изтриване на ресурс от сървъра. Примерно, ако искаме да изтрием създадения коментар.
#### PATCH
Разновидност на PUT, пак ъпдейтваме ресурс, но само частично. Примерно ако искаме да променим коментар с PUT където имаме - автор, дата, коментар и тн, повече данни, трябва да изпратим променения нов цял обект съставен от тези данни. Няма значение колко неща сме променили се изпраща нов обект. При PATCH ъпдейта може да е само на част от тези данни, без да replace-ва целия обект. Удобно е когато обекта е много голям и не искаме да пращаме целия ресурс, но само да сменим примерно дадено заглавие.
#### HEAD
Това са служебен тип заявки, които рядко се използват. Обикновено браузъра ги прави автоматично. Връща само заглавната информация за ресурса, без съдържанието (подобно на GET, но по-леко).
#### OPTIONS
Това също са служебен тип заявки и служат за запитвания какви методи и опции са позволени за даден ресурс.
#### HTTP Request
##### GET
HTTP е текстово базиран изцяло на текст протокол, който съдържа структуриран по определен начин текст.
HTTP заявката съдържа в себе си header и body, като body не е задължително. При повечето GET requests няма body. 

В header-a стои meta data - информация която описва спецификата на заявката. В body са данните, които изпращаме. Като пример с реално физическо писмо, body-то е текстът вътре - същинската информация, която искаме да предадем, а плика който дава информация за адреса на получателя и подателя е header-a. За да разбере сървъра какво очакваме от него, има нужда от мета данните.

1. **Първият ред на заявката (Request Line):**
    - Съдържа три части:
        - Името на HTTP метода (например `GET`, `POST` и т.н.).
        - **Pathname** (пътя) на ресурса, който обикновено е относителен (релативен). Например: `/users/testnakov/repos`.
        - Протокола и версията, по която се комуникира (например `HTTP/1.1`).
    - Този ред наистина е задължителен и основен за всяка заявка.
2. **Header-и:**
    - След първия ред следва блок от хедъри, които се записват в текстов вид под формата на ключ-стойност, разделени с `:` (например `Host: example.com`).
    - Въпреки че целият блок се нарича "headers", всеки ред в него също може да бъде наричан "header".
3. **Задължителни хедъри:**
    - Единственият задължителен хедър е **Host**, който указва домейна или IP адреса, към който трябва да бъде изпратена заявката (например `Host: news.bg`).
    - Всички останали хедъри са опционални и зависят от конкретната заявка или изискванията на клиента.
4. **Сървърът и опционалните хедъри:**
    - Сървърът не е длъжен да се съобрази с опционалните хедъри. Например, ако заявим `Accept-Language: bg`, но сървърът няма ресурси на български, той може да върне ресурсите на наличния език.
    - Реакцията на сървъра зависи от неговата конфигурация и възможности.
5. **Структурата на хедърите:**
    - Когато имената на хедърите съдържат повече от една дума, те обикновено използват тирета (`-`) за разделяне на думите. Например: `Content-Type`, `Accept-Language`.

Header-a свършва, когато има празен нов ред, след това следва body-то, ако има такова, като и то свършва с празен ред.

Има хедъри, като `User-Agent` който носи информация за браузъра (или клиента), който изпраща заявката, както и за операционната система и версията му.
В миналото сървърите използвали тази информация, за да адаптират отговора според спецификите на браузъра. Това било необходимо, защото различните браузъри поддържали различни технологии и имплементации на стандартите.

По време на т.нар. "войни на браузърите" (Browser Wars) между Netscape и Internet Explorer, а по-късно и други браузъри, всяка платформа въвеждала собствени функции, което водело до фрагментация и несъвместимост.
Сървърите трябвало да знаят точния браузър, за да върнат съвместими ресурси.
Браузърите започнали да се "маскират" в User-Agent, като заявявали поддръжка за повече от един браузър. Например, много браузъри днес включват Mozilla в User-Agent, дори да не са Mozilla-базирани, за да осигурят съвместимост.
Това довело до ситуация, в която User-Agent хедърът съдържа излишна или подвеждаща информация.
В съвременните условия User-Agent рядко се използва за функционални нужди, защото стандартите вече са по-унифицирани. Все пак той може да е полезен за аналитика или за специфични оптимизации, но реалната му информативна стойност е силно намалена.
##### POST
При **POST** заявката, тялото е задължително. Също така, освен стандартните хедъри като **`Host`**, има и задължителен хедър **`Content-Type`**, който показва типа на данните в тялото на заявката. Това е важно, защото сървърът трябва да знае какъв тип съдържание получава, за да го интерпретира правилно. **`Content-Type`** използва **MIME type** за разпознаване на данните.

**MIME type** (Multipurpose Internet Mail Extensions) стандарт за описание на типа съдържание, което се предава през интернет. Това е ключова част от комуникацията между клиента и сървъра, защото помага на сървъра да интерпретира правилно данните, които получава.

- **`application/json`** — JSON данни.
- **`text/html`** — HTML документи.
- **`multipart/form-data`** — за качване на файлове.

Пример за POST заявка:

```
POST /submit-form HTTP/1.1
Host: www.example.com
Content-Type: application/json
Content-Length: 123

{
  "name": "John Doe",
  "email": "johndoe@example.com"
}
```

В този случай, **`Content-Type: application/json`** показва, че тялото на заявката съдържа JSON данни. Сървърът използва този хедър, за да знае как да обработи съдържанието.

Request headers се намират в Developer Tools - Network - Headers - Request Headers.
#### HTTP Response
**Response** на сървъра е подобен на **request**, но има някои ключови различия:
1. **Response Line**:
    - Започва с версията на HTTP, например `HTTP/1.1`.
    - Следва **status code** — цифров код, който показва резултата от заявката. Например:
        - **200 OK**: Това означава, че заявката е успешна и сървърът е изпълнил заявката.
        - **404 Not Found**: Това означава, че ресурсът не може да бъде намерен. Важно е да се отбележи, че това не е грешка, а просто информация, че сървърът не може да открие търсения ресурс.
2. **Headers**:
    - Подобно на request-a, отговорът също съдържа хедъри, които предоставят допълнителна информация за отговора, като:
        - **Content-Type**: Типът на съдържанието, което сървърът връща (например `text/html`, `application/json`, и т.н.), за да помогне на браузъра да интерпретира правилно данните.
        - **Date**: Датата и часът на изпращане на отговора.
        - **Server**: Информация за сървъра, който е обработил заявката.
    - Хедърите завършват с празен ред, който показва края на хедър частта.
3. **Body**:
    - Подобно на заявката, и в отговора може да има тяло (body), което съдържа самите данни, които сървърът изпраща обратно на клиента. Това може да бъде HTML страница, JSON данни, изображения и т.н.
    - Тялото на отговора също може да завърши с празен ред, но не е задължително, тъй като самото съдържание на body-то е интерпретирано от клиентската страна.

Пример за HTTP response:

```
HTTP/1.1 200 OK
Date: Sun, 01 Dec 2024 14:01:47 GMT
Content-Type: text/html; charset=UTF-8
Server: nginx
Content-Length: 1387

<html>
  <body>
    <h1>Welcome to the website!</h1>
    <p>This is the content of the page.</p>
  </body>
</html>
```

В този пример:
- Първият ред започва с версията на HTTP и статус код (200 OK).
- Хедърите включват информация като датата, типа на съдържанието и сървъра.
- Тялото на отговора съдържа HTML код, който ще бъде интерпретиран от браузъра и показан на потребителя.

Response headers се намират в Developer Tools - Network - Headers - Response Headers, като се намират в една и съща заявка с request-a. Другата част (тялото) от responsе-a се намира в Response таба.
##### HTTP Common Status Codes
Двеста статусите са успешни като най-базовия е 200, докато следващите са по конкретни:
**200 OK** – Заявката е успешна и сървърът е върнал очаквания отговор.
**201 Created** – Заявката е успешна и е създаден нов ресурс.
**204 No Content** – Заявката е успешна, но няма съдържание за връщане.

Триста са вид преместване на ресурси:
**301 Moved Permanently** – Ресурсът е преместен на нов постоянен адрес. Клиентът трябва да използва новия URL за бъдещи заявки.
**302 Found** – Ресурсът временно е достъпен на друг адрес. Клиентът може да използва текущия URL за бъдещи заявки.

Четиристотин са напълно валидни, но говорят за грешка в request-та:
**400 Bad Request** – Невалидна заявка (например грешен синтаксис).
**401 Unauthorized** – Необходима е оторизация за достъп до ресурса.
**403 Forbidden** – Достъпът е забранен, дори и с оторизация.
**404 Not Found** – Ресурсът не е намерен.
**405 Method Not Allowed** – Използваният HTTP метод не е разрешен за ресурса.

Петстотин говорят за грешка в сървъра, примерно е недостъпен или е хвърлил необработен exception и тн. Най-честите кодове са:
**500 Internal Server Error** – Възникнала е вътрешна грешка на сървъра.
**502 Bad Gateway** – Сървърът е получил невалиден отговор от друг сървър.
**503 Service Unavailable** – Сървърът не е в състояние да обработи заявката поради временна недостъпност.

Тези статуси са основни за диагностициране на състоянието на HTTP заявките.

Забавни списъци с най-често срещаните и значими статуси:
[HTTP Cats](https://http.cat/)  
[HTTP Status Dogs API - A dog image for every HTTP Status Code](https://http.dog/)
### Developer Tools
Network tab-a в Developer Tools, може да анализираме и debug-ваме всичките HTTP заявки - requests и responses които се случват към дадения момент на комуникацията. След като отворим някоя страница, ще се появят множество заявки, всеки ред е заявка и означава request и последващия го response. В Headers таба на всеки request, може да видим към кого е направен, какъв метод е използван, какъв е отговора и тн. Браузъра започва да чете ред по ред HTML кода и прави отделни заявки, които ще се покажат като отделни заявки, примерно за шрифтове, иконки, снимки, JS, стилове и тн.

Response tab-a получаваме HTML документ, в който е цялото съдържание на поисканата страница.

Preview tab-a показва как изглежда чистия HTML, който е пристигнал с първата заявка и все още не е заредил останалите ресурси, които ще му оформят крайния вид.
### Content-Type and Disposition
**Content-Type**
- **Описание:** HTTP хедър, който указва типа на съдържанието в тялото на заявката или отговора.
- **Значение:** Помага на клиента или сървъра да разбере как да интерпретира данните.
- **Формат:** MIME тип (Multipurpose Internet Mail Extensions).
- **Примери:**
    - `text/html` – HTML документ.
    - `application/json` – JSON данни.
    - `image/png` – PNG изображение.
    - `multipart/form-data` – Данни, съдържащи файлове или формуляри.

**Content-Disposition**
- **Описание:** Хедър, използван за управление на начина, по който съдържанието се обработва от браузъра (например дали да бъде изтеглено или показано).
- **Значение:** Често се използва при качване и сваляне на файлове.
- **Основни стойности:**
    - **`inline`** – Съдържанието трябва да се покаже директно в браузъра.
    - **`attachment`** – Съдържанието трябва да се изтегли като файл.
- **Пример с изтегляне на файл:**

```
Content-Disposition: attachment; filename="example.pdf"
```

Това указва, че съдържанието е прикачен файл с име **`example.pdf`**.

**Връзката между двете**

- **`Content-Type`** указва какъв е типът на съдържанието (например PDF файл, HTML, изображение), а **`Content-Disposition`** определя какво да се прави с това съдържание (показване в браузър или сваляне).
### Postman
Това е tool, който дава възможност да се правят custom заявки и да ги конфигурираме както искаме. Браузъра е ограничен относно заявките, които може да правим, докато Postman, дава пълна свобода да конфигурираме в детайли дадена заявка - може да изберем метода, да добавим параметри, да изберем авторизация, да променим хедърите, да се изпратят и данни в body-то и да се избере формата, има и много други възможности.

След като изпратим заявката, получаваме response с всички данни подобно на това, което виждаме в браузъра. Имаме пълен и лесен начин да анализираме request-a и response-a.  
Postman е необходим и задължителен tool за един web developer, без значение дали e front end или back end.
От страна на фронт енд-а ни трябва, защото комуникираме с backend service или искаме да знаем как да си направим дадена заявка, за да постигнем определен резултат, като най-често ще тестваме дали се получава през Postman и после ще я пренесем в JS.
Ако разработваме сървър и като напишем един end point, искаме да пробваме дали клиента ще получи данните, които сме предвидили да се връщат.
### Simulating HTTPS Communication with OpenSSL
**OpenSSL** е инструмент, който позволява симулиране на комуникация между клиент и сървър през **HTTPS** (криптирания вариант на **HTTP**), използвайки **SSL/TLS** протоколите. Това е полезно за разработчици, които искат да тестват сигурността и функционалността на своите приложения през защитена комуникация, без да е необходимо да разполагат с валидни сертификати от сертифицирани органи.

**Защо използваме OpenSSL?**

**HTTPS** е основен протокол за сигурна комуникация в интернет, като добавя криптиране на стандартния **HTTP** чрез **SSL/TLS**. **OpenSSL** е широко използван за:

- **Генериране на сертификати и ключове** за криптиране на комуникацията.
- **Тестване на HTTPS комуникация** с локални сървъри и клиенти чрез симулирани връзки.
- **Криптиране на данни** по същия начин, както се случва при истински HTTPS връзки (с използване на публични и частни ключове).

**HTTPS** използва същия HTTP протокол, но с криптиране през **TLS/SSL** на порт 443. Това гарантира сигурността на комуникацията, като предотвратява подслушване и манипулиране на данните.

**Как да симулираме комуникация чрез OpenSSL?**

**Стъпки за симулиране:**

1. **Създаване на сертификат и ключ** с OpenSSL:

Генерирате self-signed сертификат, който да се използва за симулиране на HTTPS сървър:

```bash
openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365
```

Тази команда създава **server.key** (частен ключ) и **server.crt** (сертификат).

2. **Стартиране на HTTPS сървър**: Използвайте OpenSSL, за да стартирате локален HTTPS сървър:

```bash
openssl s_server -cert server.crt -key server.key -accept 443
```

3. **Свързване с клиента**: Можете да използвате OpenSSL клиент за да се свържете към сървъра:

```bash
openssl s_client -connect localhost:443
```

Тези стъпки ще симулират криптирана комуникация между клиент и сървър през **HTTPS** протокол.

**OpenSSL** позволява тестване на сигурни HTTPS връзки в тестови среди чрез генериране на сертификати и симулиране на криптирана комуникация. Това е важен инструмент за разработчиците, които искат да симулират комуникация, да тестват сигурността на приложенията си или да установят криптирани канали между клиент и сървър, като използват **SSL/TLS**, които осигуряват защита на данните.

**Стъпки за изпращане на GET заявка към даден уебсайт:**

1. **Изпращане на GET заявка чрез OpenSSL към съществуващ сайт:**
Можем да използваме **openssl s_client** за да се свържем към HTTPS сървър и да изпратим GET заявка. Например, за да изпратим заявка към `https://www.example.com`, изпълняваме следната команда:

```bash
openssl s_client -connect www.example.com:443
```

2. **Изпращане на GET заявка:**
След като връзката бъде установена, можем да въведем ръчно **GET** заявка в конзолата, както следва:

```
GET / HTTP/1.1
Host: www.example.com
```

След това натискаме **Enter** два пъти, за да изпратим заявката.

Обяснение:

- **`openssl s_client`**: Това е клиентски инструмент, който използва SSL/TLS за свързване със сървър. Чрез тази команда можем да установим сигурна връзка към даден уебсайт.
    
- **`-connect www.example.com:443`**: Това указва на OpenSSL да се свърже към сървъра на `www.example.com` на порт 443 (стандартен порт за HTTPS).
    
- **GET заявка**: Изпращаме HTTP GET заявка към сървъра за основната страница ("/"), като указваме `Host` заглавие, което е задължително за HTTPS комуникация.

**Какво ще получим в отговор:**

След изпращането на заявката ще видим не само SSL/TLS handshake информация, но и HTTP отговор от сървъра. Например, ако всичко е правилно, ще получим HTTP статус код като `HTTP/1.1 200 OK` и съдържанието на страницата.

**Защо използваме OpenSSL:**

OpenSSL осигурява възможност за комуникация със сървъри, използващи **HTTPS**, който е същият протокол като HTTP, но криптиран с SSL/TLS. Това е особено полезно за тестове и симулации, когато искаме да проверим комуникацията и сигурността на вече съществуващи уебсайтове.
## Rest
### API Endpoints and Resources
**API (Application Programming Interface)** е интерфейс, който позволява на различни системи да комуникират помежду си. Всяка система, която предоставя услуги (като например разплащателни платформи), обикновено предлага API за достъп до своите ресурси.

API-то обикновено се състои от **endpoints** – специфични URL адреси, към които можем да изпращаме HTTP заявки, за да извършваме различни **CRUD операции** (Create, Read, Update, Delete) върху ресурси. Например, когато работим с разплащателни системи като **Stripe**, техният API предоставя различни ресурси, като например информация за баланса на акаунта, който се съхранява на техните сървъри. Ресурсите са вид логическа абстракция / групиране на определен вид функционалност. Обикновено е в множествено число и е съществително име.

**Пример: Stripe API**

Stripe е популярна разплащателна система, която предлага своето API за интеграция с външни приложения. За да използваме Stripe, трябва да изпратим HTTP заявки към техните endpoints.

Документацията на Stripe API предоставя подробности как да взаимодействаме със системата, като описва какви **HTTP методи** (GET, POST, PUT, DELETE) и **pathnames** (пътища) да използваме за достъп до различни ресурси. Например, за да проверим баланса на сметката, може да изпратим GET заявка към съответния endpoint.

- **Endpoint**: Това е специфичен URL, който комбинира метод (например GET, POST) и pathname (пътя към ресурса).
- **HTTP метод**: Определя какво действие искаме да извършим върху ресурса.

**Пример за API заявка**

Ако искаме да получим информация за баланса, можем да изпратим **GET** заявка към endpoint-а на Stripe:

```bash
GET https://api.stripe.com/v1/balance
```

Тази заявка ще върне информация за баланса в JSON формат, който може да изглежда така:

```json
{
  "object": "balance",
  "available": [
    {
      "amount": 1000,
      "currency": "usd"
    }
  ],
  "pending": [
    {
      "amount": 200,
      "currency": "usd"
    }
  ]
}
```

**Резултатът от заявката**

След като изпратим заявката, ще получим **JSON обект** с информацията, която се нуждаем, съгласно документацията на API-то. JSON форматът е лесен за обработка и използва широко за обмен на данни между сървъри и клиенти.

Това обяснение показва как функционира API и как използваме **endpoints** за взаимодействие с различни ресурси на сървъра.
### REST and RESTful Services
REST (representational state transfer) е стандарт за изграждане на цялостно API на сървъра. Това е архитектура за клиент сървър комуникация през HTTP. В самия HTTP протокол, нищо не се променя, но върху него правим нова стандартизация, с цел да улесним комуникацията. 
Въпреки че имаме пълен избор да създадем **endpoints** по начина, по който искаме (например, можем да използваме **GET** за изтриване на ресурси), REST предоставя набор от добри практики, които е желателно да спазваме. Целта е да създадем логични и познати API и **endpoints**, които следват стандартите на REST.

RESTful service означава service, който спазва REST стандарта, понякога се нарича архитектура. Целта е клиентите ни да са доволни и по интуитивно да се ориентират с нашия интерфейс. Винаги когато работим с API, трябва да четем документацията, но ще е много по-лесно, ако то спазва REST стандарта.

Реално REST не е технология, не е език, не е библиотека, не се инсталира нищо, това е стандарт, който трябва да се научи и може да се ползва. Нещо което ще вложим в нашите сървъри, които правим и когато използваме чужди сървъри, ще ни е по-лесно, ако спазват REST стандарта.

 REST ни дава възможност да дефинираме ясно ресурсите. Всеки ресурс си има собствен URI (Uniform Resource Identifier). URL (Universal Resource Locator) е конкретен вид URI, с адрес, с порт и други подробности за местоположението на ресурса. Обикновено ресурсите се кръщават със съществителни и множеството число с една или повече думи - ползва се тире между тях. 
 Ресурсите може да бъдат създавани, четени, модифицирани и изтривани, но не е задължително всеки ресурс да подържа и четирите неща.
 С други думи, ресурса е нещо което отделяме и може да правим заявки върху него.

В общи линии, когато говорим за RESTful API или RESTful Service, се отнасяме до същия принцип на работа: достъп до сървърни ресурси чрез HTTP и следване на принципите на REST архитектурата.
# Misc
# ChatGPT
# Bookmarks
Забавни списъци с най-често срещаните и значими статуси:
[HTTP Cats](https://http.cat/)  
[HTTP Status Dogs API - A dog image for every HTTP Status Code](https://http.dog/)
