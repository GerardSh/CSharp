# LINQ
`Select(int.Parse or x => x * 2)` - манипулира колекцията, тоест създава нова променена на базата на старата.

`Where(predicate, index)`- филтрира елементите в колекцията, върху даден филтър. Може да се ползва в логиката на предикат функцията, освен стойността на даден елемент, но и неговия индекс.

`FirstOrDefault(optional predicate)` - връща първия елемент в колекцията, който отговаря на дадено условие, ако няма такъв връща default стойност за типа на колекцията.

`First(optional predicate)` - връща първия елемент в колекцията, който отговаря на дадено условие, ако няма такъв дава грешка.

`SingleOrDefault(optional predicate)` - връща елементa в колекцията, който отговаря на дадено условие, ако няма такъв връща default стойност за типа на колекцията. Ако има повече от един такъв елемент, връща грешка.

`Single(optional predicate)` - връща елементa в колекцията, който отговаря на дадено условие, ако няма такъв или има повече от един елемент, връща грешка.

`Any(optional predicate)` - връща true или false.

`OrderBy(key selector function)` - връща нова колекция подредена и сортирана по посочените критерии, полезно когато искаме да подредим обекти по дадено пропърти. След него може да се ползва `ThenBy(key selector function)` за допълнително сортиране. The key selector function is used to extract a key from each element in the sequence, and the elements are then sorted based on these keys.

`Take(count)` -  взима само посочения брой елементи от масива, започвайки от първия.

`Skip(count)` - Пропуска посочените елементи. Може да се комбинира със `AddRange()`
`newList.AddRange(list.Skip(2))`

`Max()` -връща максималния елемент в колекцията.

`Min()` -връща минималния елемент в колекцията.

`Sum()` - сумира елементите.

`Average()` - взима средата стойност.

`Distinct()` - взима само първите уникални елементи в дадена редица, другите биват изтрити.

 `arr1.Intersect(arr2)` - връща общите елементи между две колекции.

`SelectMany(Selector)` - обединява няколко nested collections, в примера долу values са няколко вътрешни речника:
	`test.Values.SelectMany(innerDictionary => innerDictionary).ToDictionary(x => x.Key, x => x.Value)`

`Count(optional predicate)` - връща броя на елементите в дадена колекция или тези които отговарят на дадено условие, ако има предикат.

`var numbers = Enumerable.Range(startingNumber, Count).ToList()` - връща Count на брой числа започващи от starting number.

`GroupBy(lambda)` - групира елементите в зависимост от резултата след изпълнението на ламбда-та.  Може да разделим дадени числа на четна и нечетна група и после да направим агрегации, върху всички елементи в групите, примерно да намерим сумата на елементите в двете получени групи:
```
var groups = numbers.GroupBy(x => x % 2);

foreach (var group in groups)
{
    Console.WriteLine(group.Key + " " + group.Sum());
}
```

`Aggregate()` - взима едно начално число и след това прилага операция върху текущата натрупана стойност и елементите в колекцията. Примерно ако имаме колекция с числа 1,2,3 и `var numbers = numbers.Aggregate(5, (currentValue, b) => currentValue * b);` то резултата ще е 30. Първо ще умножи първия елемент със зададеното число 5 и `currentValue` ще стане 5 х 1 = 5, после ще умножим 5 с второто число в колекцията и `currentValue` ще стане 5 х 2 = 10, накрая ще умножи последното число с `currentValue` 10 x 3 = 30. Метода може да се ползва и за конкатенация на стрингове.
# List
`Add(element)` - добавяме като последен елемент.

`Contains(element)` - проверява дали даден елемент се съдържа, връща bool резултат.

`AddRange(array)` - добавя колекция след края на елементите.

`AddRange(array.Concat(list))` - същото като горното, но обединява два масива или листа.
`newList = list.Skip(2).ToList()`

`listName.TrimExcess()` - изравнява капацитета и count-a.

`Sort()` - подрежда елементите в нарастващ ред.

`Remove(element)` - изтрива първият посочен елемент, като връща true or false дали е успял. А също и пренарежда останалите елементи, защото не оставя дупка.

`RemoveAll(element)` - премахва всички елементи с посочения елемент.

`RemoveAt(index)`-изтрива посочения елемент с дадения индекс.

`RemoveRange(index, count)` - от кой индекс, колко елемента да махне.

`InsertRange(index, collection)`- вмъква цяла колекция

`Insert(index, element)` - вмъква елемент на определена позиция в съществуващия лист. Не може да бъде посочен индекс след последния възможен. Заедно с remove са бавни методи, защото целия масив трябва да бъде пренареден. Трябва много да се внимава с елементите след индекса където се вмъква, защото индексите им са се изместили с +1. Ако swap-ваме елементи, добре е да правим копие на стойностите и на индексите които участват в размяната.

`Find(predicate)` - работи по същия начин като `FirstOrDefault` от систем LINQ, но е само за листове.

`IndexOf(element)` - връща индекса, къде се намира елемента в редицата.

`Reverse()` - обръща елементите.

`ForEach(lambda)` - обхожда колекцията и изпълнява даденото действие.
# Array
`Array.Sort(array)` - сортира елементите.

`Array.IndexOf(arr, element)` - намира индекса в редицата.

`Array.Find(arr, predicate)` - работи по същия начин като `FirstOrDefault` от систем LINQ.

`Contains(element)` - проверява дали даден елемент се съдържа, връща bool резултат.

# Multidimensional Arrays
`GetLength(dimension index)` - взима дължината на посоченото измерение.

`.Length` - дава броя на всички елементи в масива.

`.Rank` - връща колко измерения има.
# Dictionary
`Add(key,value)` - добавя елемент в масива. Ако съществува, ще върне exception.

`Remove(key)` - изтрива елемент по ключ. Ако не съществува, ще върне exception.
`ContainsKey(key)` - връща true/false.

`ContainsValue(value)` - връща true/false.

`FirstOrDeffault(optional predicate)` - може да намерим, кой е дадения key на определена стойност.

`ToDictionary(x => x.Key, x => x.Value)` - взима елементите от друго dictionary, може да разменим местата на key и value и ще имаме обърнато dictionary.
# Stack
`Push(value)` - вкарва елемент в масива.

`Pop()` - маха последния елемент от масива и го връща като стойност.

`Peek()` - показва последния елемент в масива.

`Clear()` - маха всички елементи.

`ToArray()` - вкарва елементите в масив.

`Contains(value)` - проверява дали даден елемент се съдържа.
# Queue
`Enqueue(value)` - вкарва елемент в масива.

`Dequeue()` - маха последния елемент от масива и го връща като стойност.

`Peek()` - показва последния елемент в масива.

`Clear()` - маха всички елементи.

`ToArray()` - вкарва елементите в масив.

`Contains(value)` - проверява дали даден елемент се съдържа.
# Math
`Math.Round()` - закръгля от .5 нагорe, останалите стойности надолу

`Math.Round(2.356755, 2)` - закръгля само до два знака след запетаята 2.36

`Math.Floor()` - закръгля надолу

`Math.Ceiling()` - закръгля нагоре

`Math.Pow(number, 2)` - вдига на степен, първия аргумент е числото, второто е степента
# String
`Substring(index, count)` - взима посочената стойност от даден стринг, може и без count, като така ще вземе цялата стойност, след индекса.

`Remove(index, count)` - Връща стринг с изтритите стойности, от посочения индекс и count, без count, изтрива всичко след индекса.

`Replace(textToFind, textToReplaceWith)` - променя всички места където се намира даден текст, с друг посочен текст.

`string.Join(delimiter, array)` - събира елементите от даден масив, като ги разделя с посочения разделител. Mоже да се ползва в комбинация с `Reverse()` вътре като параметър.

`string.Concat(array)` - същото като `Join()`, само че няма delimiter.

`IndexOf()` - намира индекса на първия определен символ, може да се сложи и начален индекс от който да търси. Може да търси и дали стринга има дадена поредица от символи, като ще върне индекса на първия символ в поредицата.

`LastIndexOf()` - същото като `IndexOf()`, но намира последния.

`Contains()` - Проверява дали съдържа даден символ или символи.

`Split(separator, options)` - разделя текста спрямо посочения сепаратор и връща масив. Може да split-нем и по няколко сепаратора като направим char array изреждайки ги. Интервалите може да се изрежат ползвайки Select с Trim:
```
string test = "Gosho, Tosho; Pesho";

string[] test2 = test
    .Split(new char[] { ',', ';' })
    .Select(x => x.Trim())
    .ToArray();
```
>Сплита работи, като види че има символ по който да раздели, изтрива го и добавя това което е от ляво като елемент в масива и това което е отдясно пак като елемент. Проблема е когато от 
> една от страните няма нищо, тогава в масива се добавя празен елемент.

`TrimStart('leadingCharsToDelete')` - изтрива началните посочени символи, без параметър изтрива празните пространства.

`TrimStart('endingCharsToDelete')` - изтрива началните посочени символи, без параметър изтрива празните пространства.

`Trim('optionalCharToDelete')`- изтрива началните и крайните посочени символи, без параметър, изтрива празните пространства.

`Insert(index, textToInsert)` - вкарва текст започващ от даден индекс.

`Distinct()` - взима само първите уникални елементи в даден стринг и ги вкарва в колекция от чарове, другите биват изтрити.

`StartsWith(string)` - проверява дали стринга се съдържа в началото.

`EndsWith(string)` - проверява дали стринга се съдържа в края.
# StringBuilder
Повечето от методите за стринг ги има и тук.

`Append()` - добавя нов стринг.

`AppendLine()` - също като append, но добавя и символ за край на реда.

`AppendFormat()` - може да се добавят параметри, чрез place holders.
# Char
`char.IsDigit(char)` - проверява дали е цифра.

`char.IsLetter(char)` - проверява дали е буква.

`char.IsLetterOrDigit(char)` - проверява и двете.

`char.IsPunctuation(char)` - проверява дали е пунктуационен символ.

`'\0'` - това е еквивалента на null, означава празен char.
# Stream
## StreamWriter
`WriteLine()` - вкарва текста в текстови файл.

`Flush()` - всичко което е записано до момента в буфера, се изпраща директно във файла. 

`AutoFlush = true` - пропърти, което изключва буфера.
## StreamReader
`ReadLine()` - чете ред от текстови файл.
## FileStream
`Seek(count, SeekOrigin.Begin)` - посочва колко елемента да пропусне, от началото на данните във файла.

`Seek(count, SeekOrigin.Current)` - посочва колко елемента да пропусне, от елемента в който се намира в момента.

`Seek(-count, SeekOrigin.End)` - посочва колко елемента да се върне назад, спрямо края на файла.

`Flush()` - след като байтовете биват прочетени от байт буфера, който сме направили, те се пращат във вътрешен масив и не се записват веднага на файла във хард диска. С този метод биват записани веднага.

`Read(buffer, optional startPosition, count)` - записва байтовете от даден файл в масив, като имаме възможност да посочим стартовата позиция в масива където да записва и колко байта да вземе от файла. Може да посочим повече байтове от наличните във файла, просто ще стигне до края на масива и position property-то ще показва позицията до която е стигнала главата. Връща броя на байтовете, които са вкарани в масива.

`Write(buffer, optional startPosition, count)` - записва байтовете от даден масив във файл. Може да посочим от коя позиция в масива и колко байта да запише.
### Info
Ако ползваме `FileMode.Append` - тогава ако пишем във файла и той съществува, главата винаги е разположена в края му и всичко което пишем, се записва накрая. Ако не съществува, бива създаден нов файл. Създаване на stream в този режим, не позволява използването на Seek() метода.
# File - Static
`File.ReadAllText(pathToFile)` - прочита целия текст в даден файл и го записва в стринг.

`File.ReadAllLines(pathToFile)` - прочита всички редове в даден файл и ги записва като елементи в масив от стрингове.

`File.WriteAllText(pathToFile, string)` - записва стринга в даден файл.

`File.WriteAllLines(pathToFile, arr)` - записва всички елементи от масива като отделни редове в даден файл.

`File.AppendAllText(pathToFile, string)` - добавя стринга в края на файла.

`File.Delete\Move\Copy\Create(pathToFile)` - различни действия върху файловe.

`File.Get(pathToFile)` - взимане на мета информация - в коя папка се намира, как се казва, дата на създаване, размер, собственик и тн.
# FileInfo 
Instance class with all information about a file.
# Directory - Static
`Directory.CreateDirectory(pathToDirectory)` - създаване на директория.

`Directory.Delete\Exists\Get(pathToDirectory)` - различни действия върху папките.

`Directory.Move(oldName, newName)` - преименуване на директория.

`Directory.GetFiles(pathToDirectory, "*.*", SearchOption.AllDirectories)` - връща string масив с имената на файловете с техния път в папката.  Втория параметър е search pattern, където може да заместим първия wildcard отговарящ за името на файла, втория за file extension-a. В третия параметър, може да посочим дали да търси във всички под директории или само в текущата.

`Directory.GetDirectories(pathToDirectory, "*.*", SearchOption.AllDirectories)` - връща масив от имената на под директориите в папката. Има същите допълнителни параметри, като `GetFiles()`.
# DirectoryInfo
`GetFiles()` - връща масив тип `FileInfo` с пълната мета информация за файловете в папката.  Параметър `"."` - връща имената в текущата директория.
# Path - Static
`Path.GetDirectoryName(pathToFile)` - взима името на директорията.

# Misc
## Enum
`bool isValid = Enum.TryParse("stringValue", true, out MyEnymClass result)` - опитва да парсне даден стринг към стойност в enum класа ни. Втория параметър е дали да игнорира casing-a на стринга.  Ако парсването е успешно (`isValid` е `true`), `result` ще съдържа стойността от енумерацията, съответстваща на стринга. Ако неуспешно (`isValid` е `false`), `result` ще има стойността на първия елемент от енумерацията `MyEnumClass` - този който е с най-ниска числова стойност.

`Environment.Exit(0)` - приключва изпълнението на програмата, особено полезно ако искаме да я приключим от даден метод.
## Stopwatch
`Start()` - стартира броенето на времето за което се изпълняват дадени операции.

`Stop()` - спира броенето.

`Reset()` - занулява броенето.
# General Info
Extension методите са допълнително направени методи, към даден клас в допълнение към вградените.