# Methods
## Arrays
### Mutating 
Работят директно върху оригиналния масив и го променят.
Не мутиращите, ще копират оригиналния масив в нов масив, без да променят оригиналния.

`pop()` - маха последния елемент от масива и го връща като стойност.

`push(value)` - вкарва елемент в края на масива и връща новата дължина на масива. Може да се добавят повече от един елементи.  Може да се ползва в комбинация с `...` за да добави елементите на даден масив:

```javascript
    let arr = [1, 2, 3, 4];
    let arr2 = [6, 7, 8];

    arr.push(5, ...arr2, 9); // 1, 2, 3, 4, 5, 6, 7, 8, 9
```

`shift()` - маха първия елемент, ще го върне като стойност и ще пренареди целия масив - всички елементи ще се преместят с един индекс назад.

`unshift(value)` - добавя елемент / елементи в началото на масива, което ще пренареди индексите на останалите елементи и връща новата дължина на масива.

`splice(start, deleteCount)` - махаме `deleteCount` елементи стартиращи от посочения индекс. Ако няма посочен `deleteCount`, изтрива всичко след посочения индекс. Ако индексът е отрицателен, той се брои от края на масива, примерно -1 ще е последния елемент, -2 предпоследния и така. Ако индекса излиза от рамките на масива, ще спре на последния съществуващ елемент. Връща масив с изтритите елементи, дори да е само един елемент пак ще върне масив. Ако има нужда, останалите елементи се пренареждат.

`splice(start, deleteCount, items)` - След като изтрие посочените елементи, добавя `items` елемент / елементи на тяхно място. Ако сложим 0 на `deleteCount`, тогава ще insert-не елементите на този индекс, без да изтрива нищо. 

`reverse()` - пренарежда целия масив наобратно и връща като референция същия масив.

`fill(value, start, end)` - запълва елементите в масив като `value` може да бъде всеки тип, включително обекти или масиви. Може да посочим от кой индекс да започне запълването и до кой да стигне, като `end` индекса не се включва. Ако няма `start` и `end` ще презапише стойностите на всички съществуващи елементи. Метода е удобен за инициализиране на масиви с определени стойности или за нулиране на съществуващи масиви.
Може да създадем нов масив и да му дадем начални стойности - `let arr = new Array(5).fill(0);` това ще създаде масив от 5 елемента и ще им даде стойност 0.

`sort(comparisonFunction(a, b))` - по подразбиране сортира елементите в аscending order като ги преобразува в стрингове и ги сравнява на базата на UTF-16 кодовите им единици. Така ако имаме числата `2, 3, 10` ще ги подреди грешно - `10, 2, 3`, защото в стринговото сравнение, първият символ `"1"` в `"10"` е по-малък от `"2"`. За да избегнем тези проблеми, трябва да ползваме `comparisonFunction`, която приема два аргумента и връща отрицателно число, ако първият елемент трябва да бъде преди втория, положително число, ако вторият елемент трябва да бъде преди първия и нула, ако елементите са равни.  Чрез полученото число от сравнението между двата последователни елемента, `sort()` решава как да подреди елементите.  Предимството на предоставянето на `comparisonFunction` е гъвкавостта - може да сортира по всякакви критерии, които изберем, не само по стойностите на самите елементи.

При сортиране на стрингове, се ползва `localeCompare()` метода, който е много подобен на `CompareTo()` в C#. `localeCompare()` е предпочитан метод за сортиране, тъй като е чувствителен към културните особености на текста. Така получаваме правилно подреждане, независимо от малките и главни букви или различни special characters - `"John", "José", "Anna", "Åsa", "Zara"` . Позволява по-добро сортиране на стрингове, като взема предвид локалните правила за сравнение, което е особено важно при работа с различни езици.

При сортиране на числа се ползва аритметична операция, като целта и в двата случая е да се получи число. 

```javascript
// Sorting numbers:
const numbers = [4, 2, 5, 1, 3]; 

// Ascending sorting:
numbers.sort((a, b) => a - b); // Резултат: [1, 2, 3, 4, 5]

// Descending sorting:
numbers.sort((a, b) => b - a); // Резултат: [5, 4, 3, 2, 1]

// Sorting strings:
const fruits = ["banana", "Apple", "cherry"];

// Ascending sorting:
fruits.sort((a, b) => a.localeCompare(b)); // Резултат: ["Apple", "banana", "cherry"]

// Descending sorting:
fruits.sort((a, b) => b.localeCompare(a)); // Резултат: ["cherry", "banana", "Apple"]
```

Ако искаме да сортираме по няколко критерия, както с `ThenBy()` в C#:

```javascript
const people = [
    { name: "John", age: 30 },
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 },
    { name: "Charlie", age: 25 }
];

people.sort((a, b) => {
    // Първо сортиране по възраст във възходящ ред
    if (a.age !== b.age) {
        return a.age - b.age;
    }
    // Ако възрастите са равни, сортиране по име във възходящ ред
    return a.name.localeCompare(b.name);
});

console.log(people);
// Резултат: [
//   { name: "Alice", age: 25 },
//   { name: "Charlie", age: 25 },
//   { name: "Bob", age: 30 },
//   { name: "John", age: 30 }
// ]
```

Друг вариант по който може да се направи допълнителното сортиране е ако се ползва `||` (или) оператора, за всеки допълнителен критерии, по който искаме да сортираме - `sort((a, b) => b.name.localeCompare(a.name) || a.age - b.age)`. Това работи, защото това е логически израз и ако първия израз върне 0, се свежда до `false`, и заради това `||` оператора продължава към следващия израз, понеже му трябва поне едно `true`, за да върне `true`. Ако никъде не върне `true`, елементите няма да бъдат местени. 
### Non-Mutating
Създават и връщат нов масив, без да променят оригиналния. Така оригиналният масив остава непокътнат.

`join(separator)` - обединява всички елементи в даден масив и ги връща като string разделени от посочения сепаратор. Ако няма посочен сепаратор, ще по подразбиране ще е `,`.

`slice(start, end)` - взима subarray / парче от масива, като започва от  `start` индекс и взима до `end` индекс, но не включително - `end` индекс не се включва в резултата. Връща нов масив, който съдържа изрязаните елементи. Когато нямаме зададен `end` индекс взима всичко до края, ако нямаме и `start` индекс тогава копира целия масив. Може да се ползват и отрицателни индекси.

`slice()` - ще направи shallow копие на целия масив. Новият масив ще съдържа същите елементи като оригиналния, но ще бъде независим от него. ако масивът съдържа обекти или вложени масиви, `slice()` копира само референциите към тях, а не самите обекти. Това е причината да се нарича shallow копие, а не deep копие.

`includes(searchElement, fromIndex)` - проверява дали дадена стойност я има в масива, връща boolean. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`indexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на първия срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`lastIndexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на последния срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`firstArr.concat(secondArr)` в JavaScript събира два или повече масива и връща нов масив, който съдържа елементите на събраните масиви. Може да се добавят произволен брой масиви и индивидуални стойности.

`Array.from(myIterableCollection, [mapFn, thisArg])` - преобразува всяка iterable колекция или дори обекти с итератор в масив. `mapFn` _(по избор)_ – функция, която се прилага на всеки елемент по време на преобразуването. `thisArg` _(по избор)_ – контекст, който да се използва в `mapFn`. Може да се ползва и `[...elements]`, което също convert-ва iterable колекциите в масив. 
### Iterative Methods
Тези методи са предимно non-mutating и позволяват извършването на операции върху масиви по начин, който наподобява LINQ в C#.

Приемат:
- **Callback Function**: Подобно на делегатите в C#, тези методи очакват функция като аргумент. Всички функции, които се подават като аргументи на методи в JavaScript, се наричат callback функции. Те могат да бъдат от различен тип, в зависимост от контекста, в който се използват.
- **Predicate Function**: Някои от методите, като `filter()`, приемат специален вид callback функция наречена predicate, която определя условията, по които елементите от масива ще бъдат включени в новия масив. Тази функция връща true или false, в зависимост дали елемента отговаря на условията.
- **Other Arguments**: Много от тези методи приемат и допълнителни аргументи, като `thisArg`, който задава контекста за `this` в callback функцията.
- **Index и Целия Масив**: Итеративните методи предоставят на callback функциите не само текущия елемент, но и неговия индекс и целия масив. Това позволява извършването на операции, които зависят от позицията на елемента или от самия масив.

Callback функциите, предлагат гъвкавост и могат да бъдат представени по различни начини, което улеснява работата с методи като `filter`, `map`, и `reduce`. Това прави кода по-интуитивен и по-лесен за четене! Те могат да бъдат подавани като именувана функция, анонимна функция (function expression) или стрелкова функция (arrow function).

**Примери:**

```javascript    
// Named function
    function printElement(element) {
        console.log(element);
    }

    arr.forEach(printElement);

    // Function Expression
    arr.forEach(function (element) {
        console.log(element);
    });

    // Arrow Function
    arr.forEach((element) => {
        console.log(element);
    });
```

`forEach(callback)` - изпълнява подадената функция за всеки един от елементите в масива (колекцията). Не връща стойност, а се използва за странични ефекти (side effects), които могат да променят външни променливи.

`map(callback)` - трансформира всеки един от елементите в масива, подобен е на `Select()` в C#.

`find(predicate)` - връща първия елемент, който отговаря на даден филтър.

`filter(predicate)` - връща масив с всички елементи, отговарящи на даден филтър. Ако сложим `Boolean` като аргумент, ще изтрие всички елементи с falsy стойности - `false`, `0`, `''`, `null`, `undefined` и `NaN`. 

`reduce(callbackFunction, initialValue)` - подобен на `Aggregate()` в C#, обединява всички елементи в масива до една стойност. Пълният синтаксис на `reduce` е следният:

```javascript
array.reduce(callbackFunction, initialValue);
```

**Обяснение на параметрите**

1. `callbackFunction`: Това е функцията, която се извиква за всяка итерация на елементите в масива. Тя получава обикновено следните четири аргумента, като първите два са задължителни:
- `accumulator` (стойността, която се натрупва),
- `currentValue` (текущият елемент от масива),
- `currentIndex` (индексът на текущия елемент),
- `array` (самият масив).
2. `initialValue`: Това е стойността, която се използва като начален `accumulator` за първата итерация. Ако тя не е зададена, `reduce` ще използва първия елемент на масива като начален `accumulator`, а итерацията ще започне от втория елемент.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 10);
console.log(sum); // Изход: 25
```

В този пример `initialValue` е `10`, така че `reduce` започва с натрупване, като добавя 10 към всеки елемент от масива.

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS
## String
`firstString.concat(secondString)` - събира два string-a и връща нов стринг съставен от тях.

`indexOf(searchString, position)` - намира началния индекс на първия текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`lastIndexOf(searchString, position)` - намира началния индекс на последния текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`substring(start, end)` - взима substring-а започващ от индекса start и стигащ до end без да го включва. Ако не се подаде end ще вземе всичко до края. Връща нов стринг.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`) и връща нов стринг. `searchValue` може да бъде стринг или регулярeн израз (regex). 

`replaceAll(searchValue, replaceValue)` - замества всички срещнати стрингове (`searchValue`) с ново съдържание (`replaceValue`) и връща нов стринг. `searchValue` може да бъде стринг или регулярeн израз (regex). 

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```

Ако искаме да разделим текст само по интервали и да избегнем празните елементи, които се получават, когато имаме повече от един интервал един след друг, може да използваме `/[ ]+/` в `split`. Това гарантира, че дори и да има няколко поредни интервала, те ще бъдат разглеждани като един разделител.

`string.split('')` или `[...string]` - ще направи масив от всеки отделен елемент в стринга.

`includes(searchString, position)` - проверява дали дадена стойност я има в стринга, връща boolean. Ако сложим `position` ще започне да търси от дадения индекс.

`'stringToRepeat'.repeat(count)` - повтаря `stringToRepeat` `count` на брой пъти.

`trimStart()` - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от началото на стринга.

`trimEnd() `  - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от края.

`trim()` - изтрива whitespaces (интервал, нов ред или tab) от началото и края.

`startsWith(searchString, position)` - проверява дали даден стринг започва с `searchString` и връща boolean. По избор може да се посочи и `position`, от където да започне търсенето (по подразбиране е 0). Има значение дали буквите са главни или малки.

`endsWith(searchString, position)` - проверява дали даден стринг завършва с `searchString` и връща boolean. По избор може да се посочи и `position`, от кой краен индекс да завършва търсенето (по подразбиране е дължината на стринга). Има значение дали буквите са главни или малки.

`padStart(maxLength, fillString)` - добавя padding (допълнителни символи) в началото на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.

`padEnd(maxLength, fillString)` - добавя padding (допълнителни символи) в края на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.

`charCodeAt(index)` - връща Unicode на символа на посочения индекс в стринга.

`String.fromCharCode(number)` - конвертира число в ASCII символ.

`str.split('').reverse().join('')` - обръщане на стринг наобратно.

`str1.localeCompare(str2, locales, options)` - сравнява два стринга като взема предвид езиковите правила, специфични за определена локализация.
`locales` (optional): Стринг с BCP 47 езикова таг, който определя локализацията за сравнение (например, "en" за английски, "fr" за френски).
`options` (optional): Обект, който може да съдържа опции за персонализиране на сравнението, като:
- `sensitivity`: Определя как да се третират разлики, например по базата на регистър или акценти.
- `ignorePunctuation`: Позволява игнориране на пунктуацията при сравнението.
Връща:
- Отрицателно число, ако `str1` е преди `str2`.
- Положително число, ако `str1` е след `str2`.
- Нула, ако двата стринга са равни.
## Number
`Number()` - parse-ва string към number.

`parseFloat()` - parse-ва string към number.

`parseInt()` - parse-ва string към number, като маха ако има остатък.

Разликата между `Number` и другите две е че ако string-a започва с число, то ще вземе числото и няма да върне `NaN`. Примерно при `parseFloat('3test')`, ще върне числото 3.

`Number.isInteger(value)` - връща boolean в зависимост дали подадената стойност е цяло число (integer). Това включва и отрицателните цели числа, както и нула, но изключва десетични числа и стойности, които не са от числов тип.
## Object / Associative Arrays
`Object.freeze(myObject)` - забранява на даден обект да може да се променя, трябва да го подадем на метода. Има възможност и само конкретни пропъртита да не се променят.

`Object.values(myObject)` - взима всички стойности от подадения обект и ги слага в масив. Ако в някой от методите има `this`, за да се запази оригиналния контекст, трябва да ползваме `bind()` при изпълнение на метода:

```javascript
    let dog = {
        name: 'Hero',
        bark: function () { // Function expression syntax
            console.log(`${this.name} is barking!`);
        },
    };

    let myObjectValues = Object.values(dog);

    myObjectValues[1].bind(dog)(); // Hero is barking!
    myObjectValues[1](); // undefined is barking!
```

`Object.keys(myObject)` - взима всички ключове от подадения обект и ги слага в масив. 

`Object.entries(myObject)` -  връща масив от двойки ключ-стойност, като всяка двойка е масив с два елемента: първият е ключът, а вторият е стойността.
Ако в някой от методите има `this`, за да се запази оригиналния контекст, трябва да ползваме `bind()` при изпълнение на метода:

```javascript
    let dog = {
        name: 'Hero',
        bark: function () { // Function expression syntax
            console.log(`${this.name} is barking!`);
        },
    };

    let myObjectPairs = Object.entries(dog);

    myObjectPairs[1][1].bind(dog)(); // Hero is barking!
    myObjectPairs[1][1](); // undefined is barking!
```

`Object.fromEntries(phonebookEntries)` - връща обект създаден от масив от двойки`[key, value]`, какъвто създава и `Object.entries(myObject)` метода.

`Object.assign` - копира пропъртита от един или повече изходни обекти към целеви обект и връща модифицирания целеви обект. Прави повърхностно копие (не копира вложени обекти рекурсивно). Ако има еднакви пропъртита, последният източник замества стойността в целевия обект. Ползва се често за сливане или създаване на копие на обекти

```javascript
const target = { a: 1 };
const source = { b: 2, c: 3 };
const result = Object.assign(target, source);

console.log(result); // { a: 1, b: 2, c: 3 }
console.log(target); // { a: 1, b: 2, c: 3 } - The target object is modified

const merged = Object.assign({}, obj1, obj2); // Merge

const copy = Object.assign({}, originalObject); // Copy
```

`structuredClone(object)` -  създава дълбоко копие на обекта заедно с всички вложени структури, без да споделя референции. Ако не ни трябва дълбоко копие, може да ползваме деструктуриране - `const newObj = {...objToCopy}`

`hasOwnProperty(propertyKey)` - проверява дали даден обект, съдържа определен ключ, връща boolean.

`delete myObject['key']` - за изтриване на пропърти се ползва оператора delete, като освен bracket notation, работи и dot notation.
## JSON
`JSON.stringify(myObject, replacer, space)` - конвертира даден обект и го прави в JSON, връща string. Не включва методи. `replacer` и `space` са optional параметри. 
`replacer` aко е функция, тя се извиква за всяко свойство на обекта и може да променя стойността или да изключва свойства от сериализацията. Ако е масив, той указва кои свойства да се включат. Всички други свойства ще бъдат игнорирани.

```javascript
let dog = {
    name: 'Hero',
    age: 5,
    breed: 'Swiss Shepard'
};

// Използваме replacer функция, за да изключим свойството "breed"
let jsonString = JSON.stringify(dog, (key, value) => {
    if (key === 'breed') {
        return undefined; // Изключва "breed" от сериализацията
    }
    return value; // Връща стойността на всички останали свойства
});

console.log(jsonString); // Резултат: {"name":"Hero","age":5}
```

`space` указва колко интервали да се използват за индентация. Например, `2` ще добави 2 интервала за всяко ниво на вложеност, като предимството е че става по-четимо, за сметка на ефективността, защото space-a също е символ - байтове, които също трябва да се прехвърлят:

```json
// JSON.stringify(dog);
{"name":"Hero","age":5,"breed":"Swiss Shepard"}

// JSON.stringify(dog, null, 2);
{
  "name": "Hero",
  "age": 5,
  "breed": "Swiss Shepard"
}
```

`JSON.parse(text)` - конвертира JSON string в обект и го връща. Създава нов обект с нови референтни стойности за всяко от пропъртитата. Ако конвертираме един и същи JSON string и го запишем на две променливи, референтните типове ще сочат към различни обекти.
## Console
`Console.dir(myObj)` - показва детайлна, интерактивна структура на обект, като изобразява свойствата и методите му в йерархичен формат. Използва се най-вече за разглеждане на сложни обекти като DOM елементи, което позволява лесно разгъване и навигация през свойствата им. Различава се от `console.log()`, който показва обекта като стринг.
## DOM - Document
### Getting Elements
Тези методи, може да се прилагат и да търсят в целия DOM, когато се ползват с `document.` , но може и да търсят в децата на конкретен елемент `parentElement.`.
`getElementById(id)` - връща елемента с определен id.

`getElementsByClassName(class)` - връща `HTMLCollection` с елементите, които имат определен клас.

`getElementsByTagName(tag)` - връща `HTMLCollection` с елементите, които имат определен таг.

`querySelector(CSS selector)` - връща първия елемент, отговарящ на зададения CSS selector. Може да се ползва и запетайка за да се посочат няколко селектора.

`querySelectorAll(CSS selector)` - връща `NodeList` колекция с всички елементи, отговарящи на зададения CSS selector. Може да се ползва и запетайка за да се посочат няколко селектора.
### Manipulation
`appendChild()` - закрепя създаден елемент (child) като последно дете на друг елемент (parent). Работи само с **Node** обекти (т.е. елементи, текстови възли и т.н.). Ако елементът вече съществува в DOM дървото, той се премества на новото място.

`append()` - подобен е на `appendChild()`, но е по-гъвкав, защото може да добавя както **Node** обекти, така и текстови стойности. Позволява добавяне на множество елементи наведнъж.

`prepend()` - работи като `append()`, но добавя елемента като първо дете.

`remove()` - директно премахва елемент от DOM дървото, няма нужда от родителски елемент и не връща нищо.

`parent.removeChild(child)` - използва се за премахване на конкретен дете елемент от родителския елемент в DOM дървото. За разлика от `remove()`, който директно премахва елемента, този метод изисква да се зададе както родителя, така и детето. Това е стария начин за изтриване на елементи като родителския елемент може да се вземе директно от детето - `child.parent.removeChild(child)`

`createElement()` - създава елемент от зададения тип, но той все още не е добавен към DOM дървото. Трябва да се ползват методите за добавяне.

`cloneNode(deep)` - използва се за клониране на DOM елементи. `deep` (булев параметър) – определя дали да се клонира само самият елемент или и всичките му деца.
    - `true`: Копира се целият елемент заедно с всички негови деца (цялото поддърво на DOM).
    - `false`: Копира се само самият елемент без децата му (само елемента без съдържание).

`replaceChild(newChild, oldChild)` - изтрива `oldChild` и добавя `newChild` на негово място. Метода трябва да бъде извикан върху родителския елемент. Връща старото дете. И двата елемента трябва да имат общ родител.
### Events
`myElement.addEventListener(eventName, myFunction)` - първия аргумент е името на събитието, без представката `on`. Ако натиснем `Ctrl + i` или `Ctrl + Space` вътре в скобите на метода в VS Code, излизат подсказки с всички събития. Вторият аргумент е функцията, която ще се изпълни когато събитието се случи. Третия аргумент - `useCapture` (по желание) - Булев параметър, който указва дали събитието да бъде улавяно по време на фазата на улавяне (`true`) или по време на фазата на изпълнение (по подразбиране `false`). За повечето приложения не е необходимо да се задава. 
  В обобщение този начин позволява да добавяме множество функции за едно и също събитие. Не презаписва предишните event handlers. Това означава, че можем да добавим много event handlers за същото събитие на същия елемент, без те да влизат в конфликт помежду си. Поддържа допълнителни опции, като параметъра `useCapture`, който определя в коя фаза на събитието да се изпълни даден event handler.

```javascript
const myElement = document.getElementById('myElement'); 
myElement.addEventListener('click', function() { 
console.log('Element clicked!'); 
});
```

Може да добавяме повече от един event върху даден елемент, като дори може да е от един и същи тип - ще се изпълнят и двата.

За да изтрием event listener от даден DOM елемент, трябва да ползваме метода `myElement.removeEventListener(eventName, myFunction)`. За да работи, да подадем същото име на event-a и трябва да имаме референция към функцията, която искаме да изтрием. Ако event listener-a е бил добавен като анонимна функция, няма как да го изтрием. 

`event.stopPropagation()` - ако искаме да предотвратим изпълнението на event handlers в други елементи (например, в родителския елемент или други вложени елементи). Този метод спира по-нататъшното му разпространение в DOM дървото, така че event handlers на събитието няма да се изпълнят за други елементи, които се намират в пътя му.
## Misc
`setTimeout(function, delay, param1, param2, ...)` - е асинхронен метод, като кодът вътре в тялото на функцията, ще бъде изпълнен след зададеното време на забавяне. Самото изпълнение на този код обаче не блокира останалия JavaScript код в програмата.
# RegExp
## Creating RegExp
Има два основни начина за създаване на регулярни изрази в JavaScript:
### Literals
Регулярният израз се записва между две наклонени черти (`/`). Вътре в тях пишем шаблона, който искаме да търсим.

```javascript
let pattern = /[A-Z][a-z]+/g; // Seaching for a word starting with a capital letter followed by one or more smaller letters with global flag
```

Това е начина за предпочитане, защото е по-лесен за писане, но с по-малко възможности.
### RegExp class
Регулярните изрази могат да бъдат създадени и чрез конструктора `RegExp`. Този метод е полезен, когато шаблонът е динамичен и не може да бъде зададен статично. Може да се сложат променливи вътре в самия pattern.

```javascript
let pattern = new RegExp('[A-Z][a-z]+', 'g'); // Същото търсене, но с конструктор
```
## Methods
[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Методите се делят на два вида:
### RegExp
Използват се върху самия тип на regex.

`pattern.test(string)` - тества дали патърна, ще върне резултат в търсения текст и връща boolean.

`pattern.exec(string)` - този метод връща масив където първия елемент е самото съвпадение. Останалите елементи (ако има) са резултати от групирането в регулярния израз (ако имаме групи). Ако не намери съвпадение, връща `null`. Ако има повече от едно съвпадение на регулярния израз, ще намери само първото съвпадение. 
За да намерим всички съвпадения, можем да ползваме глобалния флаг `g` -`exec()` ще запомни последната позиция на търсене и при всяко следващо извикване ще продължи оттам. Друг вариант е да се ползва стринговия метод `match()`.
### String
Стрингови методи, които използват regex вътре в аргументите си.

`match(pattern)` - връща масив с първото намерено съвпадение, който включва следните детайли: 
Съвпадащия string (или група, ако е посочена), индекса на съвпадението в стринга, целия input string. 
Ако искаме да върне всички резултати, трябва да добавим глобалния флаг `g` в pattern-на. Така ще върне масив с всички резултати, но няма да покаже никаква допълнителна информация, като индекса и input text-a.

`matchAll(pattern)` - намира всички резултати и ги добавя в `RegExpStringIterator`. Трябва да го добавим в един `for-of loop` и така може да ги видим поотделно. Трябва да има добавен глобалния флаг `g` в pattern-на.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`). `searchValue` може да бъде стринг или регулярeн израз (regex). Ако искаме да замести всички резултати отговарящи на pattern-на, трябва да има глобалния флаг `g`.

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Особено полезно е да се ползва regex, когато имаме различни сепаратори. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```