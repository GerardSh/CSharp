# Methods
## Arrays
### Mutating 
Работят директно върху оригиналния масив и го променят.
Не мутиращите, ще копират оригиналния масив в нов масив, без да променят оригиналния.

`pop()` - маха последния елемент от масива и го връща като стойност.

`push(value)` - вкарва елемент в края на масива и връща новата дължина на масива. Може да се добавят повече от един елементи.  Може да се ползва в комбинация с `...` за да добави елементите на даден масив:

```javascript
    let arr = [1, 2, 3, 4];
    let arr2 = [6, 7, 8];

    arr.push(5, ...arr2, 9); // 1, 2, 3, 4, 5, 6, 7, 8, 9
```

`shift()` - маха първия елемент, ще го върне като стойност и ще пренареди целия масив - всички елементи ще се преместят с един индекс назад.

`unshift(value)` - добавя елемент / елементи в началото на масива, което ще пренареди индексите на останалите елементи и връща новата дължина на масива.

`splice(start, deleteCount)` - махаме `deleteCount` елементи стартиращи от посочения индекс. Ако няма посочен `deleteCount`, изтрива всичко след посочения индекс. Ако индексът е отрицателен, той се брои от края на масива, примерно -1 ще е последния елемент, -2 предпоследния и така. Ако индекса излиза от рамките на масива, ще спре на последния съществуващ елемент. Връща масив с изтритите елементи, дори да е само един елемент пак ще върне масив. Ако има нужда, останалите елементи се пренареждат.

`splice(start, deleteCount, items)` - След като изтрие посочените елементи, добавя `items` елемент / елементи на тяхно място. Ако сложим 0 на `deleteCount`, тогава ще insert-не елементите на този индекс, без да изтрива нищо. 

`reverse()` - пренарежда целия масив наобратно и връща като референция същия масив.

`fill(value, start, end)` - запълва елементите в масив като `value` може да бъде всеки тип, включително обекти или масиви. Може да посочим от кой индекс да започне запълването и до кой да стигне, като `end` индекса не се включва. Ако няма `start` и `end` ще презапише стойностите на всички съществуващи елементи. Метода е удобен за инициализиране на масиви с определени стойности или за нулиране на съществуващи масиви.
Може да създадем нов масив и да му дадем начални стойности - `let arr = new Array(5).fill(0);` това ще създаде масив от 5 елемента и ще им даде стойност 0.

`sort(comparisonFunction(a, b))` - по подразбиране сортира елементите в аscending order като ги преобразува в стрингове и ги сравнява на базата на UTF-16 кодовите им единици. Така ако имаме числата `2, 3, 10` ще ги подреди грешно - `10, 2, 3`, защото в стринговото сравнение, първият символ `"1"` в `"10"` е по-малък от `"2"`. За да избегнем тези проблеми, трябва да ползваме `comparisonFunction`, която приема два аргумента и връща отрицателно число, ако първият елемент трябва да бъде преди втория, положително число, ако вторият елемент трябва да бъде преди първия и нула, ако елементите са равни.  Чрез полученото число от сравнението между двата последователни елемента, `sort()` решава как да подреди елементите.  Предимството на предоставянето на `comparisonFunction` е гъвкавостта - може да сортира по всякакви критерии, които изберем, не само по стойностите на самите елементи.

При сортиране на стрингове, се ползва `localeCompare()` метода, който е много подобен на `CompareTo()` в C#. `localeCompare()` е предпочитан метод за сортиране, тъй като е чувствителен към културните особености на текста. Така получаваме правилно подреждане, независимо от малките и главни букви или различни special characters - `"John", "José", "Anna", "Åsa", "Zara"` . Позволява по-добро сортиране на стрингове, като взема предвид локалните правила за сравнение, което е особено важно при работа с различни езици.

При сортиране на числа се ползва аритметична операция, като целта и в двата случая е да се получи число. 

```javascript
// Sorting numbers:
const numbers = [4, 2, 5, 1, 3]; 

// Ascending sorting:
numbers.sort((a, b) => a - b); // Резултат: [1, 2, 3, 4, 5]

// Descending sorting:
numbers.sort((a, b) => b - a); // Резултат: [5, 4, 3, 2, 1]

// Sorting strings:
const fruits = ["banana", "Apple", "cherry"];

// Ascending sorting:
fruits.sort((a, b) => a.localeCompare(b)); // Резултат: ["Apple", "banana", "cherry"]

// Descending sorting:
fruits.sort((a, b) => b.localeCompare(a)); // Резултат: ["cherry", "banana", "Apple"]
```

Ако искаме да сортираме по няколко критерия, както с `ThenBy()` в C#:

```javascript
const people = [
    { name: "John", age: 30 },
    { name: "Alice", age: 25 },
    { name: "Bob", age: 30 },
    { name: "Charlie", age: 25 }
];

people.sort((a, b) => {
    // Първо сортиране по възраст във възходящ ред
    if (a.age !== b.age) {
        return a.age - b.age;
    }
    // Ако възрастите са равни, сортиране по име във възходящ ред
    return a.name.localeCompare(b.name);
});

console.log(people);
// Резултат: [
//   { name: "Alice", age: 25 },
//   { name: "Charlie", age: 25 },
//   { name: "Bob", age: 30 },
//   { name: "John", age: 30 }
// ]
```
### Non-Mutating
Създават и връщат нов масив, без да променят оригиналния. Така оригиналният масив остава непокътнат.

`join(separator)` - обединява всички елементи в даден масив и ги връща като string разделени от посочения сепаратор. Ако няма посочен сепаратор, ще по подразбиране ще е `,`.

`slice(start, end)` - взима subarray / парче от масива, като започва от  `start` индекс и взима до `end` индекс, но не включително - `end` индекс не се включва в резултата. Връща нов масив, който съдържа изрязаните елементи. Когато нямаме зададен `end` индекс взима всичко до края, ако нямаме и `start` индекс тогава копира целия масив. Може да се ползват и отрицателни индекси.

`slice()` - ще направи shallow копие на целия масив. Новият масив ще съдържа същите елементи като оригиналния, но ще бъде независим от него. ако масивът съдържа обекти или вложени масиви, `slice()` копира само референциите към тях, а не самите обекти. Това е причината да се нарича shallow копие, а не deep копие.

`includes(searchElement, fromIndex)` - проверява дали дадена стойност я има в масива, връща boolean. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`indexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на първия срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`lastIndexOf(searchElement, fromIndex)` - търси дали даден елемент се съдържа в масива и връща номера на индекса на последния срещнат елемент с такава стойност, ако не го намери връща -1. Ако сложим `fromIndex` ще започне да търси от дадения индекс.

`firstArr.concat(secondArr)` в JavaScript събира два или повече масива и връща нов масив, който съдържа елементите на събраните масиви. Може да се добавят произволен брой масиви и индивидуални стойности.
### Iterative Methods
Тези методи са предимно non-mutating и позволяват извършването на операции върху масиви по начин, който наподобява LINQ в C#.

Приемат:
- **Callback Function**: Подобно на делегатите в C#, тези методи очакват функция като аргумент. Всички функции, които се подават като аргументи на методи в JavaScript, се наричат callback функции. Те могат да бъдат от различен тип, в зависимост от контекста, в който се използват.
- **Predicate Function**: Някои от методите, като `filter()`, приемат специален вид callback функция наречена predicate, която определя условията, по които елементите от масива ще бъдат включени в новия масив. Тази функция връща true или false, в зависимост дали елемента отговаря на условията.
- **Other Arguments**: Много от тези методи приемат и допълнителни аргументи, като `thisArg`, който задава контекста за `this` в callback функцията.
- **Index и Целия Масив**: Итеративните методи предоставят на callback функциите не само текущия елемент, но и неговия индекс и целия масив. Това позволява извършването на операции, които зависят от позицията на елемента или от самия масив.

Callback функциите, предлагат гъвкавост и могат да бъдат представени по различни начини, което улеснява работата с методи като `filter`, `map`, и `reduce`. Това прави кода по-интуитивен и по-лесен за четене! Те могат да бъдат подавани като именувана функция, анонимна функция (function expression) или стрелкова функция (arrow function).

**Примери:**

```javascript    
// Named function
    function printElement(element) {
        console.log(element);
    }

    arr.forEach(printElement);

    // Function Expression
    arr.forEach(function (element) {
        console.log(element);
    });

    // Arrow Function
    arr.forEach((element) => {
        console.log(element);
    });
```

`forEach(callback)` - изпълнява подадената функция за всеки един от елементите в масива (колекцията). Не връща стойност, а се използва за странични ефекти (side effects), които могат да променят външни променливи.

`map(callback)` - трансформира всеки един от елементите в масива, подобен е на `Select()` в C#.

`find(predicate)` - връща първия елемент, който отговаря на даден филтър.

`filter(predicate)` - връща масив с всички елементи, отговарящи на даден филтър.

`reduce(callbackFunction, initialValue)` - подобен на `Aggregate()` в C#, обединява всички елементи в масива до една стойност. Пълният синтаксис на `reduce` е следният:

```javascript
array.reduce(callbackFunction, initialValue);
```

**Обяснение на параметрите**

1. `callbackFunction`: Това е функцията, която се извиква за всяка итерация на елементите в масива. Тя получава обикновено следните четири аргумента, като първите два са задължителни:
- `accumulator` (стойността, която се натрупва),
- `currentValue` (текущият елемент от масива),
- `currentIndex` (индексът на текущия елемент),
- `array` (самият масив).
2. `initialValue`: Това е стойността, която се използва като начален `accumulator` за първата итерация. Ако тя не е зададена, `reduce` ще използва първия елемент на масива като начален `accumulator`, а итерацията ще започне от втория елемент.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 10);
console.log(sum); // Изход: 25
```

В този пример `initialValue` е `10`, така че `reduce` започва с натрупване, като добавя 10 към всеки елемент от масива.

[Array - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - всичките array методи в JS
## String
`firstString.concat(secondString)` - събира два string-a и връща нов стринг съставен от тях.

`indexOf(searchString, position)` - намира началния индекс на първия текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`lastIndexOf(searchString, position)` - намира началния индекс на последния текст или символ, който отговаря на търсения стринг. Ако не намери нищо, връща -1. Може да сложим position - от кой индекс да започне да търси.

`substring(start, end)` - взима substring-а започващ от индекса start и стигащ до end без да го включва. Ако не се подаде end ще вземе всичко до края. Връща нов стринг.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`) и връща нов стринг. `searchValue` може да бъде стринг или регулярeн израз (regex). 

`replaceAll(searchValue, replaceValue)` - замества всички срещнати стрингове (`searchValue`) с ново съдържание (`replaceValue`) и връща нов стринг. `searchValue` може да бъде стринг или регулярeн израз (regex). 

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```

Ако искаме да разделим текст само по интервали и да избегнем празните елементи, които се получават, когато имаме повече от един интервал един след друг, може да използваме `/[ ]+/` в `split`. Това гарантира, че дори и да има няколко поредни интервала, те ще бъдат разглеждани като един разделител.

`string.split('')` или `[...string]` - ще направи масив от всеки отделен елемент в стринга.

`includes(searchString, position)` - проверява дали дадена стойност я има в стринга, връща boolean. Ако сложим `position` ще започне да търси от дадения индекс.

`'stringToRepeat'.repeat(count)` - повтаря `stringToRepeat` `count` на брой пъти.

`trimStart()` - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от началото на стринга.

`trimEnd() `  - премахва всички водещи празни символи - whitespaces (интервали, нови редове и табулации) от края.

`trim()` - изтрива whitespaces (интервал, нов ред или tab) от началото и края.

`startsWith(searchString, position)` - проверява дали даден стринг започва с `searchString` и връща boolean. По избор може да се посочи и `position`, от където да започне търсенето (по подразбиране е 0). Има значение дали буквите са главни или малки.

`endsWith(searchString, position)` - проверява дали даден стринг завършва с `searchString` и връща boolean. По избор може да се посочи и `position`, от кой краен индекс да завършва търсенето (по подразбиране е дължината на стринга). Има значение дали буквите са главни или малки.

`padStart(maxLength, fillString)` - добавя padding (допълнителни символи) в началото на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.

`padEnd(maxLength, fillString)` - добавя padding (допълнителни символи) в края на стринга, така че да достигне зададената дължина. Ако не сложим `fillString` ще добави whitespaces. Ако `fillString` е по-дълъг от необходимото пространство, той ще бъде отрязан.

`charCodeAt(index)` - връща Unicode на символа на посочения индекс в стринга.

`String.fromCharCode(number)` - конвертира число в ASCII символ.

`str.split('').reverse().join('')` - обръщане на стринг наобратно.

`str1.localeCompare(str2, locales, options)` - сравнява два стринга като взема предвид езиковите правила, специфични за определена локализация.
`locales` (optional): Стринг с BCP 47 езикова таг, който определя локализацията за сравнение (например, "en" за английски, "fr" за френски).
`options` (optional): Обект, който може да съдържа опции за персонализиране на сравнението, като:
- `sensitivity`: Определя как да се третират разлики, например по базата на регистър или акценти.
- `ignorePunctuation`: Позволява игнориране на пунктуацията при сравнението.
Връща:
- Отрицателно число, ако `str1` е преди `str2`.
- Положително число, ако `str1` е след `str2`.
- Нула, ако двата стринга са равни.
## Number
`Number()` - parse-ва string към number.

`parseFloat()` - parse-ва string към number.

`parseInt()` - parse-ва string към number, като маха ако има остатък.

Разликата между `Number` и другите две е че ако string-a започва с число, то ще вземе числото и няма да върне `NaN`. Примерно при `parseFloat('3test')`, ще върне числото 3.

`Number.isInteger(value)` - връща boolean в зависимост дали подадената стойност е цяло число (integer). Това включва и отрицателните цели числа, както и нула, но изключва десетични числа и стойности, които не са от числов тип.
# RegExp
## Creating RegExp
Има два основни начина за създаване на регулярни изрази в JavaScript:
### Literals
Регулярният израз се записва между две наклонени черти (`/`). Вътре в тях пишем шаблона, който искаме да търсим.

```javascript
let pattern = /[A-Z][a-z]+/g; // Seaching for a word starting with a capital letter followed by one or more smaller letters with global flag
```

Това е начина за предпочитане, защото е по-лесен за писане, но с по-малко възможности.
### RegExp class
Регулярните изрази могат да бъдат създадени и чрез конструктора `RegExp`. Този метод е полезен, когато шаблонът е динамичен и не може да бъде зададен статично. Може да се сложат променливи вътре в самия pattern.

```javascript
let pattern = new RegExp('[A-Z][a-z]+', 'g'); // Същото търсене, но с конструктор
```
## Methods
[Regular expressions - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#using_regular_expressions_in_javascript) - JS RegExp методи.

Методите се делят на два вида:
### RegExp
Използват се върху самия тип на regex.

`pattern.test(string)` - тества дали патърна, ще върне резултат в търсения текст и връща boolean.

`pattern.exec(string)` - този метод връща масив където първия елемент е самото съвпадение. Останалите елементи (ако има) са резултати от групирането в регулярния израз (ако имаме групи). Ако не намери съвпадение, връща `null`. Ако има повече от едно съвпадение на регулярния израз, ще намери само първото съвпадение. 
За да намерим всички съвпадения, можем да ползваме глобалния флаг `g` -`exec()` ще запомни последната позиция на търсене и при всяко следващо извикване ще продължи оттам. Друг вариант е да се ползва стринговия метод `match()`.
### String
Стрингови методи, които използват regex вътре в аргументите си.

`match(pattern)` - връща масив с първото намерено съвпадение, който включва следните детайли: 
Съвпадащия string (или група, ако е посочена), индекса на съвпадението в стринга, целия input string. 
Ако искаме да върне всички резултати, трябва да добавим глобалния флаг `g` в pattern-на. Така ще върне масив с всички резултати, но няма да покаже никаква допълнителна информация, като индекса и input text-a.

`matchAll(pattern)` - намира всички резултати и ги добавя в `RegExpStringIterator`. Трябва да го добавим в един `for-of loop` и така може да ги видим поотделно. Трябва да има добавен глобалния флаг `g` в pattern-на.

`replace(searchValue, replaceValue)` - замества първия срещнат стринг (`searchValue`) с ново съдържание (`replaceValue`). `searchValue` може да бъде стринг или регулярeн израз (regex). Ако искаме да замести всички резултати отговарящи на pattern-на, трябва да има глобалния флаг `g`.

`split(separator, limit)` - взима стринг и го разделя на елементи спрямо дадения separator. Separator-ът може да бъде стринг или регулярeн израз (regex), което позволява разделяне по по-сложни шаблони. Особено полезно е да се ползва regex, когато имаме различни сепаратори. Може да сложим и лимит колко елемента да върне.

```javascript
let result = text.split(/[,; ]+/); // Разделя по запетая, точка и запетая или интервал, благодарение на + не се получават празни елементи
```