# General
## Steps In Database Design
### Identify Entities
Ентитито е обект, който е важен за бизнеса. Най-лесния вариант да определим ентититата, когато започнем да правим дизайна на базата ни данни идва от DDD (Domain Driven Design), където domain-a е бизнес област в която работи нашия software. Трябва да започнем изграждането на речник като започнем разговор с експерти в областта. 

Примерно, ако правим приложение за градския транспорт, по време на разговора си изваждаме domain specific думи като спирки, автобуси, билети, контрольори, маршрути, разписание и тн. Тези думички са ентититата и съответстват на таблиците в базата данни. Най-често са съществителни във спецификацията и каквото и да прочетем в нея, трябва да говорим и със специалистите във въпросната област.

Друг пример - трябва да разработим система, която съхранява информация за студенти, обучаващи се в различни курсове. Курсовете се провеждат в различни градове. При регистриране на нов студент се въвежда следната информация: име, факултетен номер, снимка и дата.

Entities: Student, Course, Town.
### Identify Table Columns
Има колони, които са служебни и са задължителни. Домейн специфичните колони, се намират най-лесно отново в процеса на разговора като обсъдим ентититата, примерно спирката си има адрес, номерация, състояние, връзка с автобусите, които спират там и тн. 
В примера със студентите, всеки студент си има име, но има детайли, които трябва да се обсъдят, като това когато студента влиза в системата, дали тя се обръща към него с цялото му име или само фамилия и тн. 
Друг детайл е дали и трите имена да се включват в сертификатите. Ние като IT експерти, трябва да преценим как точно, къде, до каква степен имаме право да съхраняваме данните и тн.

Добре е да има допълнителни колони, примерно колона която пази датата на създаване на даден запис, кой го е създал и тн. Това са специални колони, които е добра практика да се създават.
### How to Choose a Primary Key
Първичния ключ е едно от най-важните неща в една таблица. Важен е защото, това е нещото, което еднозначно идентифицира записа. Той е абсолютно уникален и е начина, по който достъпваме правилните данни. Много хора правят грешката да използват бизнес термини. Това е голяма грешка, защото колкото и бизнеса да ни уверява че нещо е уникално и то ще остане винаги такова, не трябва да му се вярва. Затова бизнес данните, не трябва да се ползват като ключ, за да се избегне колизия.

В повечето случаи ключът трябва да бъде число, защото числата се обработват бързо. Понякога това не е достатъчно поради огромния обем на генерираните данни, и тогава дори `long` (64 бита) не е достатъчен. В краен случай може да се използва `GUID` (Globally Unique Identifier 128 бита). Той също работи бързо и не може да бъде отгатнат, което е важно, тъй като съществуват атаки, базирани на ID-та.

Ако ползваме цяло число, primary key-a задължително трябва да е `IDENTITY` с auto-increment. Базата данни е среда на силна конкурентност и ако ние даваме числата, може да се дублират, докато базата е проектирана в среда на конкурентост да ги създава сама, без да ги дублира. Може да се получи дупка в идентификатора, ако възникне грешка, но няма да има дублиране. 
При `GUID` `IDENTITY` не работи, защото `GUID` не е последователен тип данни. `GUID` стойностите са случайно или псевдослучайно генерирани и не се вписват в концепцията за автоматично увеличаване. Ако обаче искаме да използваме `GUID` като ключ, можем да използваме други механизми, като например:
- `NEWID()`: Функция, която генерира уникален `GUID` за всяка нова стойност.
- `NEWSEQUENTIALID()`: Функция, която генерира `GUID` с последователност, за да се оптимизира производителността при индексиране.

Primary key-a, е добре да бъде първа колона. След създаването на таблицата, колоните не може да се пренареждат.

Не е добре да се ползва текст, защото се създава по-неефективни индекси, а те са много важни, защото се търси бързина - много бързо да може да се изкарат данните. При текстови индекси, нещата са доста по-зле от колкото при числови индекси.
### Identify Entity Relationships
Често имаме зависимости между различните ентитита, примерно между автобуси и спирки или студенти, курсове и градове. Връзките са важни и трябва да бъдат дефинирани. 

Примерно студентите са обучават в курсове, което означава че щом имаме много студенти и те се обучават в много курсове, имаме връзка many-to-many. 

Курсовете се провеждат в градове, тук връзката може да е many-to-one или many-to-many, ако даден курс се провежда в различни градове. 
Спецификацията е placeholder-a за разговор - виждаме множественото число между курсове и градове, но за да може да определим със сигурност каква е връзката, трябва да говорим с някой който може да потвърди точно къде и как се провеждат курсовете.

Промяната на релациите в базата данни е трудна задача. Понеже релацията е нещо доста фундаментално и рядко има такива фундаментални промени в бизнеса.
## Database Normalization
Нормализацията е систематичен подход за де композиране на таблиците с цел да се премахне повторението на данните, както и ни пази от аномалии.

Това е организация на данните в определена структура. Първото нещо, което трябва да направим е данните да бъдат атомарни (atomicity), защото много по-лесно работим с тях и бързо намираме това, което ни трябва.
Атомарни означава, че не данните не би трябвало да може да бъдат разделяне повече от това до където сме ги разделили.

Релационните бази данни са проектирани, така че да минимизират размера на данните, които се пълнят вътре. Поради това има типове данни, като повечето от тях имат ограничения, за да може да се впишат в определени байтове. Примерно може да изберем `VARCHAR`, но ще го ограничим до даден брой символи. Така базата данни, знае колко място да запази.

Ако дублираме едни и същи данни много пъти, отново получаваме нарастване обема на данни. В този случай, може да заместим данните с нещо по-кратко, примерно да заместим дадено име и дори не само името, но и други свързани данни, като имейл и телефон, само с едно число. По този начин на всяко място, където се изисква тази информация, вместо да се въвеждат всички свързани данни, могат да бъдат заместени с един номер. Това е една от основните цели, справяне с дедупликацията на данни, да може да намали обема на записаните данни. Това води и до увеличаване на скоростта с която може да се прочетат и манипулират данните.

Това е многостъпков процес, като за нас са важни първите три, които са достатъчни да премахнем аномалиите и да достигнем достатъчна степен на дедуплициране на данните.
### Normal Forms
#### First Normal Form (1NF)
1. Таблицата трябва да има атомарна / единична стойност. Означава че в една колона, не може да запишем повече от една стойност. Примерно даден човек има повече от един имейл адрес, не трябва да ги записваме в една колона и ще наруши първата нормална форма. Това, което трябва да се направи е да се въведе същия човек като отделен запис за всеки различен имейл адрес, който има, като всички останали данни остават същите. Получават се дублирани данни, но това е първата стъпка, към нормализацията.
2. Стойностите записани в колоната, трябва да са от един и същи тип. Базата няма да го позволи, но това че сме избрали стринг, не значи че не може да запишем дадено число като стринг и ако в един запис сме записали име а в друг запис число в същата колона, не е правилно.
3. Всички колони в таблицата, трябва да имат уникални имена. Самата база няма да позволи да има дублиране на имената, но примерно ако имаме таблица в която съхраняваме специалности за хора, и използваме имена като Специалност 1, Специалност 2, това е нарушение на принципите на нормализация. 
4. Реда в който се съхраняват данните, не би трябвало да има значение.
#### Second Normal Form (2NF)
1. Трябва да изпълнява условията на първа нормална форма, понеже всяка следваща форма надгражда предишната.
2. Няма частични зависимости. Частична зависимост се появява, когато атрибут (колона) зависи само от част от съставен първичен ключ, а не от целия ключ.

**Съставен / композитен първичен ключ**

Съставен първичен ключ е ключ, който се състои от **две или повече колони** и заедно те уникално идентифицират всеки ред в таблицата.

Например:

| Студент ID | Курс ID | Оценка | Име на студент | Име на курс |
| ---------- | ------- | ------ | -------------- | ----------- |

- Тук **Студент ID + Курс ID** са съставен първичен ключ, защото само комбинацията от тези две стойности прави реда уникален.
- Колоната **Оценка** зависи от целия ключ (**Студент ID + Курс ID**).
- Но колоната **Име на студент** зависи само от **Студент ID**, а колоната **Име на курс** зависи само от **Курс ID**. Това са частични зависимости.

**Какво трябва да направим?**

За да приведем таблицата във втора нормална форма (2NF), трябва да **премахнем частичните зависимости**, като разделим таблицата на повече таблици.

**Пример: Таблица, която е в 1NF, но не е в 2NF**

|Студент ID|Курс ID|Оценка|Име на студент|Име на курс|
|---|---|---|---|---|
|1|101|5.50|Иван Иванов|Програмиране|
|1|102|4.50|Иван Иванов|Математика|
|2|101|6.00|Петър Петров|Програмиране|

**Проблем:**

- **Име на студент** зависи само от **Студент ID**.
- **Име на курс** зависи само от **Курс ID**.
- Това са частични зависимости, което означава, че таблицата не е в 2NF.

**Решение: Разделяне на таблицата**

1. **Таблица за студенти** (Информация за студентите):  
    | Студент ID | Име на студент |  
    |------------|----------------|  
    | 1 | Иван Иванов |  
    | 2 | Петър Петров |
    
2. **Таблица за курсове** (Информация за курсовете):  
    | Курс ID | Име на курс |  
    |---------|------------------|  
    | 101 | Програмиране |  
    | 102 | Математика |
    
3. **Таблица за записвания** (Връзката между студенти и курсове, включително оценките):  
    | Студент ID | Курс ID | Оценка |  
    |------------|---------|--------|  
    | 1 | 101 | 5.50 |  
    | 1 | 102 | 4.50 |  
    | 2 | 101 | 6.00 |
    

**Какво постигнахме?**

- Таблицата за студенти съхранява само информация, която зависи от **Студент ID**.
- Таблицата за курсове съхранява само информация, която зависи от **Курс ID**.
- Таблицата за записвания съхранява информация, която зависи от **комбинацията от Студент ID и Курс ID** (съставния ключ).

Така вече няма частични зависимости и таблиците са във втора нормална форма (2NF).

**Заключение:**

**Втора нормална форма (2NF)** е приложима само когато има съставен първичен ключ. Ако първичният ключ се състои от една единствена колона, концепцията за частични зависимости не се прилага и таблицата автоматично отговаря на изискванията за (2NF), стига да изпълнява правилата на първата нормална форма (1NF).
#### Third Normal Form (3NF)
1. Трябва да изпълнява условията за първа и втора нормална форма (1NF и 2NF).
2. Не трябва да има транситивни зависимости. Транзитивна зависимост възниква, когато една колона зависи от друга колона, която не е част от първичния ключ. 
   Например, ако `А` зависи от `B`, а `B` зависи от `C`, тогава `А` зависи транзитивно от `C`.
   
**Пример:**

**Ненормализирана таблица:**

|**id**|**name**|**department_id**|**department_name**|
|---|---|---|---|
|1|Иван|101|Маркетинг|
|2|Петър|102|Продажби|

**Транзитивна зависимост:**

`department_name` зависи от `department_id`, а не директно от `id`.
Това нарушава правилото за 3NF, защото `department_name` не зависи единствено от първичния ключ (`id`).

Това е проблем, защото `department_name` зависи от `department_id`, което означава, че ако променим името на отдела в един ред, трябва да го променим навсякъде в таблицата. Това е излишно дублиране на данни и увеличава риска от несъответствия.

**Решение: Разделяне на таблицата**

1. **Таблица: Служители (Employees):**  
    | **id** | **name** | **department_id** |  
    |--------|-----------|-------------------|  
    | 1 | Иван | 101 |  
    | 2 | Петър | 102 |
    
2. **Таблица: Отдели (Departments):**  
    | **department_id** | **department_name** |  
    |-------------------|---------------------|  
    | 101 | Маркетинг |  
    | 102 | Продажби |

**Обобщение:**

Третата нормална форма (3NF) гарантира, че няма излишни зависимости между колоните, освен тези, които пряко зависят от първичния ключ. Това се постига чрез елиминиране на транситивните зависимости. Ключовият принцип е, че **всяка колона в таблицата трябва да зависи само и единствено от първичния ключ и от нищо друго.**
### Denormalization
Денормализацията понякога е по-добро решение, особено при **data warehouse** бази, където целта е да се улесни достъпът до големи обеми данни. `JOIN` операциите са ресурсно натоварващи и когато трябва да се събира информация от множество таблици, това може да доведе до забавяне. Затова в **data warehouse** базите данните често са денормализирани, за да се улеснят справките и агрегациите.

**Видове бази:**

1. **Оперативни бази данни** – нормализирани, за да осигурят целостта и ефективността на транзакциите.
2. **Аналитични бази данни** – денормализирани, за да се оптимизират справките върху големи обеми информация.

Често базите данни първо се нормализират, за да се гарантира целостта и ефективността на транзакциите. Впоследствие данните преминават през процес на трансформация и денормализация, при който се създават отделни структури, оптимизирани за справки и анализи. Тези денормализирани данни обикновено се съхраняват в аналитични системи, като **data warehouse**, за да улеснят извличането на информация и агрегациите.
## Table Relations
### Foreign Key
Връзките между таблиците се изграждат чрез релации от тип primary key -> foreign key, където foreign key в една таблица обикновено препраща към primary key в друга таблица. Ако не е primary key в другата таблица, foreign key трябва да е поне уникален. Това осигурява референтна цялост и гарантира, че свързаните данни са консистентни.

Когато ползваме релация, ние не повтаряме данните, ако има нужда да се промени нещо, го променяме само на едно място.
### Custom Column Properties
**Primary Key**

```sql
Id INT NOT NULL PRIMARY KEY
```

При този вариант, сами трябва да си подаваме Id-то, като сървъра няма да ни позволи да го дублираме.

**Identity (auto-increment)**

```sql
Id INT PRIMARY KEY IDENTITY
```

**Unique constraint - no repeating values in entire table**

```sql
Email VARCHAR(50) UNIQUE
```

Когато искаме нещо да е уникално, но да не е първичен ключ, защото той при всички случаи е уникален, може да ползваме `UNIQUE` constraint-a. 
### Multiplicity
**One-to-many** - e.g. country / towns
 - една държава, много градове.
 
**Many-to-many** - e.g. student / course  
 - един студент има много курсове.
 - един курс има много студенти.

**One-to-one** - e.g.  person / passport
- един човек има само един паспорт.
- един паспорт принадлежи само на един човек.
# ChatGPT
## Comparison: Entities, Tables, and Classes
Tables in a database are analogous to **classes** in C#, and **entities** in a database usually correspond to tables. Here's the comparison:

1. **Entities**
    
    - Represent real-world objects or concepts in a domain (e.g., Bus, Stop, Route).
    - **In a database, entities are typically modeled as tables.**
2. **Tables (Database)**
    
    - Represent structures for storing data about specific entities.
    - Example: The `Buses` table corresponds to the **Bus entity**.
3. **Classes (C#)**
    
    - Represent templates for creating objects that mirror the data and behavior of entities.
    - Example: A `Bus` class defines the properties and behavior of the Bus entity.

**Similarities**

|**Entity**|**Table (Database)**|**Class (C#)**|
|---|---|---|
|Conceptual model|Physical structure for data|Logical structure for objects|
|Attributes|Columns|Properties|
|Instances|Rows|Objects|

**Example:**

**Entity:** Bus (concept)  
**Table in Database:**

```
Buses
| ID  | Number  | Brand | Capacity |
|-----|---------|-------|----------|
| 1   | 123     | MAN   | 50       |
| 2   | 456     | Volvo | 60       |
```

**C# Class:**

```csharp
public class Bus
{
    public int ID { get; set; }
    public string Number { get; set; }
    public string Brand { get; set; }
    public int Capacity { get; set; }
}
```

**C# Instances:**

```csharp
var bus1 = new Bus { ID = 1, Number = "123", Brand = "MAN", Capacity = 50 };
var bus2 = new Bus { ID = 2, Number = "456", Brand = "Volvo", Capacity = 60 };
```

**Differences**

- **Entities** are abstract concepts that describe objects in the real world.
- **Tables** implement entities as structured data in a database.
- **Classes** model entities in code for use in an application during runtime.

**Conclusion**

Entities in a database are most often represented as **tables**, while their attributes are modeled as columns. In C#, entities are mirrored by **classes** that define their properties and behavior. This analogy helps connect database design with object-oriented programming.
# Bookmarks
Completion: 07.01.2025