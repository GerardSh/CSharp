# General
## Indices
Базата данни позволява много бързо намиране на информация, когато данните са подредени с индекси. Индексите ускоряват търсенето на стойности в определени колони или групи от колони.

Обикновено индексите са имплементирани като двоични дървета за търсене (B-trees).

Индексите могат да бъдат вградени в таблицата (clustered) или запазени външно (non-clustered).

При **clustered** индексите самите данни са част от индекса, докато при **non-clustered** индексите имаме отделна структура.

- **Non-clustered index**:
    
    - Позволява множество индекси върху една таблица.
    - Представлява отделна структура, която се обновява при всяка промяна в данните.
    - Работи с указатели, които насочват към данните.

Ако използваме **clustered индекс**, указателят на **non-clustered индекс** сочи към него. Ако няма **clustered индекс**, указателят сочи директно към данните, което е по-бавно.

**Предимства и недостатъци:**

Добавянето и триенето на записи в индексирани таблици е по-бавно, защото индексите трябва да се обновява, поради което не винаги са подходящи. Обикновено индексите се ползват за таблици с над 500 000 реда.

Важно е да се поставят индекси само на колоните, които често участват в заявките, като например в `WHERE`, `JOIN`, `GROUP BY` или `ORDER BY` клаузи. Няма смисъл да се индексират всички колони, тъй като това:

- Увеличава размера на базата данни. Индексите са допълнителни обекти, които растат заедно с таблицата и могат да заемат значително дисково пространство, особено при големи таблици с много индекси. Всеки индекс създава структура, която изисква място за съхранение. При добавяне, актуализиране или изтриване на данни, индексите също трябва да се обновяват, което увеличава натоварването.
- Забавя операциите за добавяне, обновяване и изтриване на записи, защото индексите трябва да се обновяват при всяка промяна.

Примерно ако имаме таблица със служители. Обикновено заявките към тази таблица ще търсят информация за служител:

- По **ID** (уникален идентификатор).
- По **Name**, ако често се налага търсене на служители по име.

В този случай е логично да добавим индекси върху колоните за **ID** и **Name**, тъй като те се използват редовно при търсене и филтриране.

Обаче, ако таблицата съдържа колони като **Address**, **Mobile Number** или **Hire Date, и тези колони не участват в заявки, няма смисъл да се индексират. Такива индекси биха довели до по-бавно записване и актуализиране на данни, без реална полза за изпълнението на заявките.

Индексите трябва да се прилагат стратегически, като се фокусираме върху колоните, които имат ключово значение за производителността на заявките. Това ще осигури баланс между бързодействие при четене и ефективност при записване и поддръжка на данните.

Ако знаем, че дадена колона винаги върви заедно с друга в заявки, можем да ги обединим в **съставен индекс** (composite index). Съставният индекс включва повече от една колона и може да подобри производителността на заявките, които използват тези колони заедно.
Съставният индекс ще бъде ефективен **само когато търсенето включва всички обединени колони или първата(ите) от тях**, в зависимост от реда на колоните в индекса. Ако търсенето е само по някоя от другите колони, индексът може да не бъде използван оптимално.

Добра практика е първоначално да не се създават индекси. Ако се наблюдава забавяне, анализът на заявките може да покаже къде да се добавят индекси за ускоряване на производителността.

Друг подход е данните първоначално да се записват в таблица без индекси. След това, с помощта на **background job**, записите се прехвърлят периодично в друга, предварително индексирана таблица.

Този метод позволява:

- По-бързо записване на данни, тъй като липсата на индекси намалява времето за операцията.
- Индексираната таблица да се оптимизира за четене и заявки, без да се влияе от постоянно обновяване.

Обикновено този подход се използва в системи с голям обем транзакции, където записите са много на брой и основният приоритет е бързото им записване. Индексирането се прави по-късно, за да се осигури по-добра производителност при четене.
### Clustered Index
Изключително бърз – осигурява директен достъп до данните, тъй като подрежда физическата структура на таблицата по стойностите на колоната (или колоните), които са част от индекса.

Може да има само един на таблица, защото определя физическата подредба на данните.

Много полезен за бързо изпълнение на оператори като `WHERE`, `ORDER BY` и `GROUP BY`, както и за операции по филтриране, сортиране и групиране.

Обикновено `clustered index` е върху Primary Key колоната, тъй като тя често е уникална и използвана за достъп до редове.

Ако няма определен clustered index, таблицата се съхранява като heap – неподредена структура, където данните не са сортирани. Това прави операциите за търсене по-бавни в сравнение с таблици с clustered index.

В SQL Server данните в таблица с `clustered index` са винаги подредени по стойностите в индекса. Ако няма такъв индекс, данните остават несортирани (heap).

Данните не са автоматично подредени по ID, освен ако изрично не създадем `clustered index` върху ID колоната (например чрез Primary Key). Ако няма такъв индекс, редовете ще бъдат съхранявани в произволен ред в heap структурата.
Ако създадем Primary Key върху `ID`, SQL Server автоматично създава `clustered index` върху него.
В този случай редовете ще бъдат физически подредени по ID. Ако премахнем Primary Key или не зададем clustered index, таблицата ще се държи като heap.
# Misc
# ChatGPT
# Bookmarks
Completion: 18.01.2025