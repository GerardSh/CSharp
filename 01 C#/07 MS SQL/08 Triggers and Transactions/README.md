# General
## Transactions
Транзакциите са последователност от операции, които се изпълняват като едно цяло. Всички операции, които са част от една транзакция, се разглеждат като едно цяло. Трябва всички да са завършили успешно, не може да има частичен успех или всички успяват или никоя.

Примерно, ако имаме банков трансфер от една сметка в друга и след като дадена сума е излязла от първата сметка, възниква проблем и тази сума не може да се прехвърли във втората сметка, тогава парите се възстановяват обратно в първата сметка.
### Lifecycle
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250126235627.png)
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250127133602.png)

Има три характерни неща за всяка транзакция:
- начално състояние `x`, което е durable, тоест стабилно.
- поредица от reads и writes.
- крайно състояние `y`, което също е стабилно.

Искаме нашата база да е винаги в стабилно състояние и да знаем че данните са консистентни и че отговарят на всички правила на базата данни. Ако някое от действията fail-не, се извършва `ROLLBACK` - връща състоянието към началното състояние, преди изпълнението на дадената транзакция - durable starting state.
Всяка транзакция трябва да знае, кое е началното й състояние.

Когато всички промени успеят, тогава се извиква командата `COMMIT`. Идеята е, че в началото сме запомнили преди да започне транзакцията, стабилното състояние `x`, след което е започнало изпълненията на някакви действия, които не са нарушили нито едно от наличните правила и са запазили данните консистентни, като това може да стане чрез проверка или чрез constrains. Когато извикаме командата `COMMIT` правим преход от стабилно състояние `x` към стабилно състояние `y`.
### Behavior
Транзакциите гарантират консистентността и интегритета на базата данни. Всички промени по време на транзакцията са временни. Запазването на тези промени се случва на веднъж след извикване на `COMMIT`.
### What Can Go Wrong?
Част от операциите fail-нат, поради software или database server crash или потребителя спре изпълнението, докато все още е в in progress.

Няколко транзакции опитващи да работят върху едни и същи данни.
### Syntax
```sql
CREATE PROC usp_Withdraw (@withdrawAmount DECIMAL(18,2), @accountId
INT)
AS
BEGIN TRANSACTION
UPDATE Accounts SET Balance = Balance - @withdrawAmount
WHERE Id = @accountId
IF @@ROWCOUNT <> 1 -- Didn’t affect exactly one row
BEGIN
 ROLLBACK
 THROW 50001, 'Invalid account!’, 1
 RETURN
END
COMMIT
```

`@@ROWCOUNT` в примера е специална променлива, която сървъра е попълнил за нас и съдържа бройката на резултатите, колко резултата са върнати от съответния statement. Ако резултатите са различни от 1, се прави `ROLLBACK`, защото сме засегнали повече от една или нито една сметка.
## ACID Models - Solving Problems Before They Arise
Идеята на ACID е да не позволи да се стигне до възникването на проблеми.

Не всички съвременни системи за управление на бази данни са ACID, част от тях покриват част от този модел, докато други не се интересуват изобщо.
Понякога се налага да стъпим малко настрани от това данните ни да са абсолютно консистентни, за сметка на нещо друго, примерно по-голяма производителност / скорост.

ACID модела се е наложил като стандарт при RDBMS-ите.

ACID е съкратено от:

**Atomicity:**

Транзакциите се изпълняват цялостно - или всички операции в дадена транзакция се изпълняват или никоя.

**Consistency:**

Базата данни се намира в стабилно състояние, преди и след края на транзакцията.

Само валидни данни се записват в базата данни.

Транзакциите не може да нарушават правилата на базата данни.

**Isolation:**

Когато няколко транзакции се изпълняват едновременно, не се отразява на изпълнението и резултата на другата.

Транзакциите не виждат не commit-тнатите промени на другите транзакции, но имаме възможност да решим какво се вижда и какво не, като се използват различни нива на изолация.

Нивото на изолация определя, колко изолирани са една от друга транзакциите.

Примерно, ако двама или повече клиента се опитат да купят последен продукт, само един от тях ще успее.

**Durability:**

След като бъде commit-тната, транзакцията става постоянна - не може да бъде загубена или върната.

Подсигурява се от database transaction logs. Чрез тях, дори да възникне проблем в базата данни, може да я възстановим до определено стабилно състояние. За целта трябва да си пуснем логовете и да логваме заявките, които правим, въпреки че ще заема повече място.

Примерно след като дадени пари са прехвърлени и commit-нати, DB сървъра спира да работи поради липсва на ток, но данните са записани и не се загубват.
## Triggers
Приличат на stored procedures, но не се изпълняват, когато ние решим. Изпълнява се, когато възникне определено събитие, не може да го ползваме като функция.

Закачат се към дадена таблица и работят само за нея.

Fire-ват, когато определен тип SQL statement се изпълни към таблицата.

Делят се на два вида:

AFTER INSERT/UPDATE/DELETE - изпълнява се след определено действие в SQL.

INSTEAD OF INSERT/UPDATE/DELETE - изпълнява се вместо определено действие в SQL, напълно подменя самата операция.
### Events
Събитието, трябва да е нещо, което променя базата данни, иначе няма смисъл от triggers. Трите събития, при които може да добавим triggers са `INSERT`, `UPDATE` и `DELETE`.

Event-a се указва с ключовата дума `FOR`, трябва да кажем trigger-a за кой event е.
# Misc
# ChatGPT
# Bookmarks
Completion: 28.01.2025