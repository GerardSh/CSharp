# General
## Transactions
Транзакциите са последователност от операции, които се изпълняват като едно цяло. Всички операции, които са част от една транзакция, се разглеждат като едно цяло. Трябва всички да са завършили успешно, не може да има частичен успех или всички успяват или никоя.

Примерно, ако имаме банков трансфер от една сметка в друга и след като дадена сума е излязла от първата сметка, възниква проблем и тази сума не може да се прехвърли във втората сметка, тогава парите се възстановяват обратно в първата сметка.
### Lifecycle
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250126235627.png)
![](https://github.com/GerardSh/SoftwareUniversity/blob/main/99%20Attachments/Pasted%20image%2020250127133602.png)

Има три характерни неща за всяка транзакция:
- начално състояние `x`, което е durable, тоест стабилно.
- поредица от reads и writes.
- крайно състояние `y`, което също е стабилно.

Искаме нашата база да е винаги в стабилно състояние и да знаем че данните са консистентни и че отговарят на всички правила на базата данни. Ако някое от действията fail-не, се извършва `ROLLBACK` - връща състоянието към началното състояние, преди изпълнението на дадената транзакция - durable starting state.
Всяка транзакция трябва да знае, кое е началното й състояние.

Когато всички промени успеят, тогава се извиква командата `COMMIT`. Идеята е, че в началото сме запомнили преди да започне транзакцията, стабилното състояние `x`, след което е започнало изпълненията на някакви действия, които не са нарушили нито едно от наличните правила и са запазили данните консистентни, като това може да стане чрез проверка или чрез constrains. Когато извикаме командата `COMMIT` правим преход от стабилно състояние `x` към стабилно състояние `y`.
### Behavior
Транзакциите гарантират консистентността и интегритета на базата данни. Всички промени по време на транзакцията са временни. Запазването на тези промени се случва на веднъж след извикване на `COMMIT`.
### What Can Go Wrong?
Част от операциите fail-нат, поради software или database server crash или потребителя спре изпълнението, докато все още е в in progress.

Няколко транзакции опитващи да работят върху едни и същи данни.
### Syntax
```sql
CREATE PROC usp_Withdraw (@withdrawAmount DECIMAL(18,2), @accountId
INT)
AS
BEGIN TRANSACTION
UPDATE Accounts SET Balance = Balance - @withdrawAmount
WHERE Id = @accountId
IF @@ROWCOUNT <> 1 -- Didn’t affect exactly one row
BEGIN
 ROLLBACK
 THROW 50001, 'Invalid account!’, 1
 RETURN
END
COMMIT
```

`@@ROWCOUNT` в примера е специална променлива, която сървъра е попълнил за нас и съдържа бройката на резултатите, колко резултата са върнати от съответния statement. Ако резултатите са различни от 1, се прави `ROLLBACK`, защото сме засегнали повече от една или нито една сметка.
## ACID Models - Solving Problems Before They Arise
Идеята на ACID е да не позволи да се стигне до възникването на проблеми.

Не всички съвременни системи за управление на бази данни са ACID, част от тях покриват част от този модел, докато други не се интересуват изобщо.
Понякога се налага да стъпим малко настрани от това данните ни да са абсолютно консистентни, за сметка на нещо друго, примерно по-голяма производителност / скорост.

ACID модела се е наложил като стандарт при RDBMS-ите.

ACID е съкратено от:

**Atomicity:**

Транзакциите се изпълняват цялостно - или всички операции в дадена транзакция се изпълняват или никоя.

**Consistency:**

Базата данни се намира в стабилно състояние, преди и след края на транзакцията.

Само валидни данни се записват в базата данни.

Транзакциите не може да нарушават правилата на базата данни.

**Isolation:**

Когато няколко транзакции се изпълняват едновременно, не се отразява на изпълнението и резултата на другата.

Транзакциите не виждат не commit-тнатите промени на другите транзакции, но имаме възможност да решим какво се вижда и какво не, като се използват различни нива на изолация.

Нивото на изолация определя, колко изолирани са една от друга транзакциите.

Примерно, ако двама или повече клиента се опитат да купят последен продукт, само един от тях ще успее.

**Durability:**

След като бъде commit-тната, транзакцията става постоянна - не може да бъде загубена или върната.

Подсигурява се от database transaction logs. Чрез тях, дори да възникне проблем в базата данни, може да я възстановим до определено стабилно състояние. За целта трябва да си пуснем логовете и да логваме заявките, които правим, въпреки че ще заема повече място.

Примерно след като дадени пари са прехвърлени и commit-нати, DB сървъра спира да работи поради липсва на ток, но данните са записани и не се загубват.
## Triggers
Приличат на stored procedures, но не се изпълняват, когато ние решим. Изпълнява се, когато възникне определено събитие, не може да го ползваме като функция.

Закачат се към дадена таблица и работят само за нея.

Fire-ват, когато определен тип SQL statement се изпълни към таблицата.

Делят се на два вида:
### AFTER Triggers
`AFTER INSERT/UPDATE/DELETE` - изпълнява се след определено действие в SQL.

```sql
CREATE TRIGGER tr_AddToLogsOnAccountUpdate
ON Accounts FOR UPDATE
AS
 INSERT INTO Logs(AccountId, OldAmount, NewAmount, UpdatedOn)
 SELECT i.Id, d.Balance, i.Balance, GETDATE()
 FROM inserted AS i
 JOIN deleted AS d ON i.Id = d.Id
 WHERE i.Balance != d.Balance
```

`inserted` и `deleted` са специални обекти в SQL Server и са за конкретната таблица. В `inserted` се намират новите данни, в `deleted` са старите данни.
Конвенцията за наименуване е да се добавя `tr_` преди името, което е в PascalCase.
### INSTEAD OF Triggers
`INSTEAD OF INSERT/UPDATE/DELETE` - изпълнява се вместо определено действие в SQL, като напълно подменя самата операция.

```sql
CREATE OR ALTER TRIGGER tr_SetIsDeletedOnDelete
ON AccountHolders
INSTEAD OF DELETE
AS
 UPDATE AccountHolders SET IsDeleted = 1
 WHERE Id IN (SELECT Id FROM deleted)
```

Когато изтрием нещо, ще бъде добавено в `deleted` обектите, от където може да си извадим `Id`.
### Events
Събитието, трябва да е нещо, което променя базата данни, иначе няма смисъл от triggers. Трите събития, при които може да добавим triggers са `INSERT`, `UPDATE` и `DELETE`.

Event-a се указва с ключовата дума `FOR`, трябва да кажем trigger-a за кой event е.
## Database Security
SQL Server има две нива на database сигурност, базирани върху роли. Комбинацията от тези роли, определя правата които има всеки един от потребителите на SQL Server.
В Object Explorer на SQL Server Management Studio (SSMS) можем да намерим папката `Security`, която е налична на две нива:
1. На ниво Server
    - Съдържа папката `Logins`, която управлява потребителите, имащи достъп до сървъра.
    - Чрез нея можем да:
        - Създаваме нови логини (logins).
        - Задаваме сървър роли (Fixed Server Roles) за контролиране на правата.
2. На ниво Database
    - Съдържа обекти като `Users` и `Roles`, които се използват за управление на достъпа и правата в рамките на конкретна база данни.
### Fixed Server Roles
- `sysadmin`
- `bulkadmin`
- `dbcreator`
- `securityadmin`

Тези роли важат за целия сървър.
### Fixed Database Roles
- `db_owner`
- `db_securityadmin`
- `db_accessadmin`
- `db_backupoperator`
- `db_ddladmin`
- `db_datareader` / `db_datawriter`

Тези роли важат за конкретна база данни.
### Custom Roles
В SQL Server можем да създаваме custom роли, които позволяват присвояването на специфични права. Това е особено полезно за организиране на групи потребители с идентични нужди от достъп.

**Предимства:**
- Улесняват управлението на правата за групи потребители.
- Правят auditing operations по-лесни и ефективни.
# Misc
# ChatGPT
# Bookmarks
Completion: 28.01.2025